<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>日プ新世界 ピラミッドメーカー</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --panel:#121a2b;

      --text:#e8eefc;
      --muted:#a9b6d6;
      --line:rgba(255,255,255,.12);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --r:14px;

      --gap:4px;

      /* JSで内幅から決定（はみ出し防止＋小さめ） */
      --slotSize: 54px;
      --slotMax: 64px;

      --benchSize: 52px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      background: radial-gradient(1200px 600px at 20% -10%, rgba(80,120,255,.25), transparent 60%),
                  radial-gradient(900px 500px at 80% 0%, rgba(160,90,255,.18), transparent 55%),
                  var(--bg);
      color:var(--text);
    }

    header{
      background: rgba(11,15,26,.72);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:12px 16px}
    h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.2px}

    button{
      height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:0 12px;
      cursor:pointer;
      box-shadow:none;
    }
    .arrowBtn{
  width:36px;
  padding:0;
  font-size:18px;
  display:flex;
  align-items:center;
  justify-content:center;
  }
    
    button:active{transform: translateY(1px)}

    main{max-width:1100px;margin:0 auto;padding:10px 16px 60px}

    /* sticky: ピラミッド＋ベンチだけ固定 */
    .stickyWrap{
      position: sticky;
      top: 0;
      z-index: 30;
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .panel{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 8px 6px 10px;
    }
    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 0 0 6px;
      color: var(--muted);
      font-size: 12px;
    }
    .bar strong{color:var(--text); font-weight:900}

    /* pyramid */
    .rows{display:flex; flex-direction:column; gap:6px}
    .row{
      display:flex;
      justify-content:center;
      gap: var(--gap);
      width: 100%;
      flex-wrap: nowrap;
    }
    .slotWrap{
      width: var(--slotSize);
      flex: 0 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
    }
    .slot{
      width: var(--slotSize);
      aspect-ratio: 1 / 1;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(255,255,255,.05);
      border: 2px solid transparent;
      cursor:pointer;
      touch-action: manipulation;
    }
    .slot img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      border-radius:999px;
    }
    .slot.active{
      outline: 2px solid rgba(110,190,255,.85);
      outline-offset: 0px;
    }
    .slot.empty{
      background: rgba(255,255,255,.04);
      border: 1px dashed rgba(255,255,255,.14);
    }

    .slotInfo, .benchInfo{
      width: 100%;
      text-align:center;
      line-height: 1.15;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .slotInfo .line, .benchInfo .line{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      font-size: clamp(8px, 2.2vw, 10px); /* 長い子は小さく寄る */
      color: rgba(232,238,252,.92);
    }

    /* bench */
    .benchRow{
      display:flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 2px;
      -webkit-overflow-scrolling: touch;
    }
    .benchItemWrap{
      width: var(--benchSize);
      flex: 0 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
    }
    .benchItem{
      width: var(--benchSize);
      aspect-ratio:1/1;
      border-radius:999px;
      overflow:hidden;
      background: rgba(255,255,255,.05);
      border: 2px solid rgba(255,255,255,.10);
      cursor:pointer;
      touch-action: manipulation;
    }
    .benchItem img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .benchItem.activeBench{
      outline: 2px solid rgba(110,190,255,.85);
      outline-offset: 0px;
    }
    .benchItem.pendingDelete{
      outline: 2px solid rgba(255,200,90,.95);
      outline-offset: 0px;
    }

    .benchCollapsed .benchInfo{ display:none; }
    .benchCollapsed .benchItemWrap{ gap:0; }

    /* options (スクロールで流れる) */
    .optionsPanel{
      margin-top: 12px;
      background: rgba(255,255,255,.05);
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 10px;
    }
    .optionsTitle{
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 8px;
    }
    .toggles{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      max-height: 120px;
      overflow:auto;
      padding-right:4px;
      margin-bottom: 10px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size: 12px;
      user-select:none;
      white-space:nowrap;
    }
    .chip input{ accent-color: #7fb6ff; }
    .chip input:disabled{ opacity:.5; }

    .sortBox{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    select{
      height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(18,26,43,.95);
      color:var(--text);
      padding:0 12px;
      outline:none;
    }

    /* grid */
    .gridSection{margin-top: 12px}
    .grid{
      display:grid;
      gap:10px;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    }
    @media (max-width: 1100px){
      .grid{ grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 360px){
      .grid{ grid-template-columns: repeat(3, 1fr); }
    }
    .card{
      position:relative;
      background: linear-gradient(180deg, rgba(18,26,43,.95), rgba(15,22,38,.96));
      border:2px solid rgba(255,255,255,.10);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, border-color .12s ease, filter .12s ease;
    }
    .card:hover{transform: translateY(-2px)}
    .thumb{
      aspect-ratio: 1 / 1;
      width:100%;
      background: rgba(255,255,255,.06);
      display:block;
      object-fit: cover;
    }
    .meta{padding:8px 8px 10px}
    .name{font-size:13px;font-weight:900;line-height:1.2;margin:0 0 4px}
    .sub{font-size:11px;color:var(--muted);margin:0}

    .card.selected{
      border-color: rgba(110,190,255,.85);
      filter: saturate(1.05);
      box-shadow: 0 0 0 2px rgba(110,190,255,.18), var(--shadow);
    }
    .card.pendingDelete{
      border-color: rgba(255,200,90,.95);
      box-shadow: 0 0 0 2px rgba(255,200,90,.18), var(--shadow);
    }

    .idx{
      position:absolute;
      top:8px; left:8px;
      height:20px;
      padding:0 7px;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      font-size:11px;
      font-weight:900;
      color:rgba(255,255,255,.95);
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <h1>日プ新世界 ピラミッドメーカー</h1>
  </div>
</header>

<main>
  <section class="stickyWrap">
    <div class="panel" id="pyramidPanel">
      <div class="rows" id="pyramid"></div>
    </div>

    <div class="panel" id="benchPanel">
      <div class="bar">
        <div><strong>ベンチ</strong> <span id="benchCount"></span></div>
        <button id="toggleBench" type="button" class="arrowBtn">⌄</button>
      </div>
      <div class="benchRow" id="bench"></div>
    </div>
  </section>

  <!-- 全解除（流れてOK） -->
  <div style="margin-top:10px; display:flex; justify-content:flex-end;">
    <button id="clear" type="button">全解除</button>
  </div>

  <section class="optionsPanel">
    <p class="optionsTitle">表示する項目（３つまで）</p>
    <div class="toggles" id="toggles"></div>

    <div class="sortBox">
      <select id="sortKey"></select>
      <select id="sortDir">
        <option value="asc">昇順</option>
        <option value="desc">降順</option>
      </select>
    </div>
  </section>

  <section class="gridSection">
    <div class="grid" id="grid"></div>
  </section>
</main>

<script>
  const CSV_PATH = "data/master.csv";

  const gridEl = document.getElementById("grid");
  const pyramidEl = document.getElementById("pyramid");
  const benchEl = document.getElementById("bench");
  const benchCountEl = document.getElementById("benchCount");
  const togglesEl = document.getElementById("toggles");
  const pyramidPanelEl = document.getElementById("pyramidPanel");
  const benchPanelEl = document.getElementById("benchPanel");

  const sortKeyEl = document.getElementById("sortKey");
  const sortDirEl = document.getElementById("sortDir");

  const ROWS = [1,2,3,5];
  const TOTAL = ROWS.reduce((a,b)=>a+b,0);

  const EXCLUDE_KEYS = new Set([
    "id","ID","Id",
    "img","image","Image","画像","photo","Photo",
    "__idx"
  ]);

  const CLASS_COL = "シグナルソングクラス";
  const CLASS_COL_ALT = "signal_class";

  const CLASS_COLOR = {
    "A":"#ff69b4",
    "B":"#ffa500",
    "C":"#7fffd4",
    "D":"#2b2b2b",
    "F":"#a9a9a9"
  };

  const state = {
    header: [],
    people: [],
    byId: new Map(),
    slots: Array(TOTAL).fill(null),
    bench: [],
    activeSlotIndex: null,   // スロット入替の選択
    activeBenchIndex: null,  // ベンチ→ピラミッド入替の選択
    displayKeys: [],
    show: {},
    sortKeys: [],
    lastTappedId: null,      // 2回タップ削除用
    benchCollapsed: false,
    classFrameOn: false,     // 枠色ON/OFF
  };

  const SPECIAL_FRAME_TOGGLE = "__frame__";

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

  function splitCsvLine(line){
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i=0;i<line.length;i++){
      const c = line[i];
      if (c === '"'){
        if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if (c === "," && !inQ){
        out.push(cur); cur = "";
      } else {
        cur += c;
      }
    }
    out.push(cur);
    return out;
  }

  function parseCsvWithHeader(text){
    const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.trim() !== "");
    if (!lines.length) return { header: [], rows: [] };
    const header = splitCsvLine(lines[0]).map(h => h.trim());
    const rows = [];
    for (let i=1;i<lines.length;i++){
      const cols = splitCsvLine(lines[i]);
      const obj = {};
      for (let j=0;j<header.length;j++){
        obj[header[j]] = (cols[j] ?? "").trim();
      }
      rows.push(obj);
    }
    return { header, rows };
  }

  function pickField(obj, keys){
    for (const k of keys){
      if (obj[k] != null && String(obj[k]).trim() !== "") return String(obj[k]).trim();
    }
    return "";
  }

  function normalizePeople(rows){
    return rows.map((r, idx) => {
      const id = pickField(r, ["id","ID","Id"]) || String(idx+1);
      const img  = pickField(r, ["img","image","Image","画像","photo","Photo"]);
      return { id, img, raw: r, __idx: idx };
    });
  }

  function isInSlots(id){ return state.slots.includes(id); }
  function isInBench(id){ return state.bench.includes(id); }
  function isSelected(id){ return isInSlots(id) || isInBench(id); }

  function removeIdEverywhere(id){
    const si = state.slots.indexOf(id);
    if (si >= 0) state.slots[si] = null;
    const bi = state.bench.indexOf(id);
    if (bi >= 0) state.bench.splice(bi, 1);
  }

  function firstEmptySlot(){ return state.slots.findIndex(x => !x); }

  function swapSlots(a, b){
    const tmp = state.slots[a];
    state.slots[a] = state.slots[b];
    state.slots[b] = tmp;
  }

  function swapSlotWithBench(slotIndex, benchIndex){
    const slotId = state.slots[slotIndex] || null;
    const benchId = state.bench[benchIndex] || null;
    if (!benchId) return;

    state.slots[slotIndex] = benchId;

    if (slotId){
      state.bench[benchIndex] = slotId; // ★順番はそのまま（場所だけ入替）
    } else {
      state.bench.splice(benchIndex, 1); // 空枠は消す
    }
  }

  function getClassColor(person){
    if (!person) return "";
    const cls = (person.raw?.[CLASS_COL] || person.raw?.[CLASS_COL_ALT] || "").trim();
    return CLASS_COLOR[cls] || "";
  }

  // ★写真サイズ：パネル内幅と「画面幅の半分」を基準に決定（小さめ + はみ出し防止）
  function updateSlotSize(){
    if (!pyramidPanelEl) return;

    const st = getComputedStyle(pyramidPanelEl);
    const padL = parseFloat(st.paddingLeft) || 0;
    const padR = parseFloat(st.paddingRight) || 0;
    const inner = Math.max(0, pyramidPanelEl.clientWidth - padL - padR);

    const root = getComputedStyle(document.documentElement);
    const gap = parseFloat(root.getPropertyValue("--gap")) || 4;
    const slotMax = parseFloat(root.getPropertyValue("--slotMax")) || 64;

    const targetWidth = Math.min(inner, Math.floor(window.innerWidth * 0.5)); // ★ここが「半分」
    const size = Math.min(slotMax, Math.floor((targetWidth - (4 * gap)) / 5));

    document.documentElement.style.setProperty("--slotSize", Math.max(34, size) + "px");
  }

  function buildDisplayKeysFromHeader(header){
    const keys = header.filter(h => h && !EXCLUDE_KEYS.has(h));
    return keys;
  }

  function selectedToggleCount(){
    let c = 0;
    for (const k of state.displayKeys){
      if (state.show[k]) c++;
    }
    return c;
  }

  function renderToggles(){
    const picked = selectedToggleCount();
    const max = 3;
    const disableNew = picked >= max;

    const chips = state.displayKeys.map(key => {
      const checked = state.show[key] ? "checked" : "";
      const disabled = (!state.show[key] && disableNew) ? "disabled" : "";
      return `
        <label class="chip">
          <input type="checkbox" data-key="${escapeHtml(key)}" ${checked} ${disabled}>
          ${escapeHtml(key)}
        </label>
      `;
    });

    // 枠色ON/OFF（表示する項目とは別枠だけど、ここに入れる）
    const frameChecked = state.classFrameOn ? "checked" : "";
    chips.unshift(`
      <label class="chip">
        <input type="checkbox" data-key="${SPECIAL_FRAME_TOGGLE}" ${frameChecked}>
        枠色（シグナルソングクラス）
      </label>
    `);

    togglesEl.innerHTML = chips.join("");
  }

  togglesEl.addEventListener("change", (e) => {
    const cb = e.target.closest("input[type=checkbox]");
    if (!cb) return;

    const key = cb.dataset.key;

    if (key === SPECIAL_FRAME_TOGGLE){
      state.classFrameOn = cb.checked;
      renderPyramid();
      renderBench();
      renderGrid();
      return;
    }

    const currentlyOn = selectedToggleCount();
    if (!state.show[key] && cb.checked && currentlyOn >= 3){
      cb.checked = false;
      return;
    }

    state.show[key] = cb.checked;

    renderToggles(); // disabled更新
    renderPyramid();
    renderBench();
    renderGrid();
  });

  function buildInfoLines(person){
    if (!person) return [];
    const r = person.raw || {};
    const lines = [];
    for (const key of state.displayKeys){
      if (!state.show[key]) continue;
      const v = (r[key] ?? "").trim();
      if (!v) continue;
      lines.push(v);
      if (lines.length >= 3) break;
    }
    return lines;
  }

  function buildSortKeys(header){
    const excludeForSort = new Set(["img","image","Image","画像","photo","Photo"]);
    return header.filter(h => h && !excludeForSort.has(h));
  }

  function renderSortSelect(){
    sortKeyEl.innerHTML = state.sortKeys.map(k =>
      `<option value="${escapeHtml(k)}">${escapeHtml(k)}</option>`
    ).join("");

    if (state.sortKeys.includes("Name")) sortKeyEl.value = "Name";
    else if (state.sortKeys.includes("名前")) sortKeyEl.value = "名前";
    else sortKeyEl.value = state.sortKeys[0] || "";
  }

  function toSortableValue(v){
    const s = String(v ?? "").trim();
    const n = Number(s);
    if (s !== "" && Number.isFinite(n)) return { type:"num", v:n };
    return { type:"str", v:s };
  }

  function getSortedPeople(){
    const arr = [...state.people];
    const key = sortKeyEl.value;
    const dir = sortDirEl.value;

    arr.sort((a,b) => {
      const av = toSortableValue(a.raw[key]);
      const bv = toSortableValue(b.raw[key]);

      let cmp = 0;
      if (av.type === "num" && bv.type === "num") cmp = av.v - bv.v;
      else cmp = String(av.v).localeCompare(String(bv.v), "ja", { numeric:true, sensitivity:"base" });

      return dir === "desc" ? -cmp : cmp;
    });

    return arr;
  }

  function renderPyramid(){
    let cursor = 0;

    const rowsHtml = ROWS.map(n => {
      const items = [];
      for (let i=0;i<n;i++){
        const idx = cursor++;
        const id = state.slots[idx];
        const p = id ? state.byId.get(id) : null;
        const imgSrc = p?.img ? escapeHtml(p.img) : "";
        const lines = buildInfoLines(p);

        const frameColor = (state.classFrameOn ? getClassColor(p) : "");
        const style = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

        const slotCls = [
          "slot",
          id ? "" : "empty",
          state.activeSlotIndex === idx ? "active" : ""
        ].filter(Boolean).join(" ");

        items.push(`
          <div class="slotWrap">
            <div class="${slotCls}" ${style} data-slot="${idx}" role="button" tabindex="0">
              ${id && imgSrc ? `<img src="${imgSrc}" alt="" loading="lazy" />` : ``}
            </div>
            ${lines.length ? `
              <div class="slotInfo">
                ${lines.map(t => `<div class="line">${escapeHtml(t)}</div>`).join("")}
              </div>
            ` : ``}
          </div>
        `);
      }
      return `<div class="row">${items.join("")}</div>`;
    }).join("");

    pyramidEl.innerHTML = rowsHtml;
  }

  function renderBench(){
    const collapsedClass = state.benchCollapsed ? "benchCollapsed" : "";
    benchPanelEl.classList.toggle("benchCollapsed", state.benchCollapsed);

    benchCountEl.textContent = state.bench.length ? `（${state.bench.length}）` : "";

    const html = state.bench.map((id, i) => {
      const p = state.byId.get(id);
      const imgSrc = p?.img ? escapeHtml(p.img) : "";
      const lines = buildInfoLines(p);

      const frameColor = (state.classFrameOn ? getClassColor(p) : "");
      const style = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

      const activeCls = (state.activeBenchIndex === i) ? "activeBench" : "";
      const delCls = (state.lastTappedId === id) ? "pendingDelete" : "";

      return `
        <div class="benchItemWrap">
          <div class="benchItem ${activeCls} ${delCls}" ${style} data-index="${i}" data-id="${escapeHtml(id)}" role="button" tabindex="0">
            ${imgSrc ? `<img src="${imgSrc}" alt="" loading="lazy" />` : ``}
          </div>
          ${(!state.benchCollapsed && lines.length) ? `
            <div class="benchInfo">
              ${lines.slice(0,2).map(t => `<div class="line">${escapeHtml(t)}</div>`).join("")}
            </div>
          ` : ``}
        </div>
      `;
    }).join("");

    benchEl.innerHTML = html;
  }

  function getCardTitleAndSub(person){
    const lines = buildInfoLines(person);

    const fallbackNameKey = state.header.includes("Name") ? "Name"
      : state.header.includes("名前") ? "名前"
      : null;

    const title = lines[0] || (fallbackNameKey ? (person.raw[fallbackNameKey] || "") : "");
    const sub = lines.slice(1,3).join(" / ");

    return { title, sub };
  }

  function renderGrid(){
    const arr = getSortedPeople();

    const html = arr.map((p, i) => {
      const selected = isSelected(p.id) ? "selected" : "";
      const pendingDelete = (state.lastTappedId === p.id) ? "pendingDelete" : "";
      const imgSrc = p.img ? escapeHtml(p.img) : "";

      const frameColor = (state.classFrameOn ? getClassColor(p) : "");
      const borderStyle = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

      const { title, sub } = getCardTitleAndSub(p);
      const idx = i + 1;

      return `
        <div class="card ${selected} ${pendingDelete}" ${borderStyle} data-id="${escapeHtml(p.id)}" role="button" tabindex="0">
          <span class="idx">${idx}</span>
          ${imgSrc
            ? `<img class="thumb" src="${imgSrc}" alt="${escapeHtml(title)}" loading="lazy"
                 onerror="this.style.display='none'; this.insertAdjacentHTML('afterend','<div style=&quot;aspect-ratio:1/1;background:rgba(255,255,255,.06);display:block&quot;></div>')" />`
            : `<div style="aspect-ratio:1/1;background:rgba(255,255,255,.06);display:block"></div>`
          }
          <div class="meta">
            <p class="name">${escapeHtml(title)}</p>
            <p class="sub">${escapeHtml(sub)}</p>
          </div>
        </div>
      `;
    }).join("");

    gridEl.innerHTML = html;
  }

  // ピラミッド枠操作：
  // - 1回目：枠選択（入替の起点）
  // - 同じ枠2回目：削除
  // - 枠選択中に別枠：入替
  // - ベンチ選択中に枠：ベンチ↔枠 入替
  function onSlotClick(slotIndex){
    const slotId = state.slots[slotIndex] || null;

    // ベンチ側を先に選んでる → 入替
    if (state.activeBenchIndex != null){
      swapSlotWithBench(slotIndex, state.activeBenchIndex);
      state.activeBenchIndex = null;
      state.activeSlotIndex = null;
      state.lastTappedId = null;
      renderPyramid(); renderBench(); renderGrid();
      return;
    }

    // 同じ枠2回目 → 削除
    if (state.activeSlotIndex === slotIndex){
      if (slotId) state.slots[slotIndex] = null;
      state.activeSlotIndex = null;
      state.lastTappedId = null;
      renderPyramid(); renderBench(); renderGrid();
      return;
    }

    // 枠選択中に別枠 → 入替
    if (state.activeSlotIndex != null && state.activeSlotIndex !== slotIndex){
      swapSlots(state.activeSlotIndex, slotIndex);
      state.activeSlotIndex = null;
      state.lastTappedId = null;
      renderPyramid(); renderBench(); renderGrid();
      return;
    }

    // 1回目：枠選択
    state.activeSlotIndex = slotIndex;
    state.activeBenchIndex = null;
    state.lastTappedId = slotId; // その子の削除候補（2回目で削除）
    renderPyramid(); renderBench(); renderGrid();
  }

  // ベンチ/一覧の子タップ：
  // - 同じ子2回連続タップ：削除（選択済みだけ）
  // - 枠選択中：枠↔ベンチ(その場所) or 枠に入れる
  // - それ以外：未選択なら追加 / 選択済みならベンチ選択（入替用）
  function onPickId(id, fromBench=false, benchIndex=null){
    // 2回連続タップなら削除（選択済みのみ）
    if (state.lastTappedId === id && isSelected(id)){
      removeIdEverywhere(id);
      state.lastTappedId = null;
      state.activeBenchIndex = null;
      state.activeSlotIndex = null;
      renderPyramid(); renderBench(); renderGrid();
      return;
    }

    // 枠選択中なら：入替/差し替え
    if (state.activeSlotIndex != null){
      if (fromBench && benchIndex != null){
        // ★順番入替なしで場所だけ交換
        swapSlotWithBench(state.activeSlotIndex, benchIndex);
      } else {
        // 一覧から来た：そのまま枠へ（既にベンチに居るならベンチ位置保持で交換）
        const bi = state.bench.indexOf(id);
        if (bi >= 0){
          swapSlotWithBench(state.activeSlotIndex, bi);
        } else {
          // 未選択 → 枠に入れて、枠の元の子はベンチへ（末尾に追加）
          const occupant = state.slots[state.activeSlotIndex] || null;
          state.slots[state.activeSlotIndex] = id;
          if (occupant) state.bench.push(occupant);
        }
      }
      state.activeSlotIndex = null;
      state.activeBenchIndex = null;
      state.lastTappedId = null;
      renderPyramid(); renderBench(); renderGrid();
      return;
    }

    // ここからは「枠選択なし」

    // 1回目タップは削除候補として記録
    state.lastTappedId = id;

    // 未選択なら追加
    if (!isSelected(id)){
      const empty = firstEmptySlot();
      if (empty >= 0) state.slots[empty] = id;
      else state.bench.push(id);
      state.lastTappedId = null;
      state.activeBenchIndex = null;
      renderPyramid(); renderBench(); renderGrid();
      return;
    }

    // 選択済み：ベンチ側を選んで入替準備（ベンチ内にいる場合だけ）
    if (fromBench && benchIndex != null){
      state.activeBenchIndex = benchIndex;
    } else {
      const bi = state.bench.indexOf(id);
      state.activeBenchIndex = (bi >= 0) ? bi : null;
    }

    renderPyramid(); renderBench(); renderGrid();
  }

  async function loadData(){
    const res = await fetch(CSV_PATH, { cache: "no-store" });
    const text = await res.text();
    const { header, rows } = parseCsvWithHeader(text);

    state.header = header;

    state.displayKeys = buildDisplayKeysFromHeader(header);
    for (const k of state.displayKeys){
      if (!(k in state.show)) state.show[k] = false;
    }
    for (const k of Object.keys(state.show)){
      if (!state.displayKeys.includes(k)) delete state.show[k];
    }

    state.sortKeys = buildSortKeys(header);

    state.people = normalizePeople(rows);
    state.byId = new Map(state.people.map(p => [p.id, p]));

    state.slots = state.slots.map(id => (id && state.byId.has(id)) ? id : null);
    state.bench = state.bench.filter(id => state.byId.has(id));

    state.activeSlotIndex = null;
    state.activeBenchIndex = null;
    state.lastTappedId = null;

    renderToggles();
    renderSortSelect();

    updateSlotSize();
    renderPyramid(); renderBench(); renderGrid();
  }

  pyramidEl.addEventListener("click", (e) => {
    const slot = e.target.closest(".slot");
    if (!slot) return;
    onSlotClick(Number(slot.dataset.slot));
  });

  benchEl.addEventListener("click", (e) => {
    const item = e.target.closest(".benchItem");
    if (!item) return;
    onPickId(item.dataset.id, true, Number(item.dataset.index));
  });

  gridEl.addEventListener("click", (e) => {
    const card = e.target.closest(".card");
    if (!card) return;
    onPickId(card.dataset.id, false, null);
  });

  sortKeyEl.addEventListener("change", renderGrid);
  sortDirEl.addEventListener("change", renderGrid);

  document.getElementById("clear").addEventListener("click", () => {
    state.slots = Array(TOTAL).fill(null);
    state.bench = [];
    state.activeSlotIndex = null;
    state.activeBenchIndex = null;
    state.lastTappedId = null;
    renderPyramid(); renderBench(); renderGrid();
  });

document.getElementById("toggleBench").addEventListener("click", () => {
  state.benchCollapsed = !state.benchCollapsed;
  document.getElementById("toggleBench").textContent = state.benchCollapsed ? "⌃" : "⌄";
  renderBench();
});

  window.addEventListener("resize", () => {
    updateSlotSize();
    renderPyramid();
  });

  loadData();
</script>
</body>
</html>
