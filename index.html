<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Produce101 11人ピラミッドメーカー</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --panel: rgba(18,26,43,.70);
      --text:#e8eefc;
      --muted:#a9b6d6;
      --line:rgba(255,255,255,.12);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --r:14px;

      --gap:6px;
      --slotMax: 52px;
      --slotSize: min(var(--slotMax), calc((100% - (4 * var(--gap))) / 5));
      --benchSize: 44px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      background: radial-gradient(1200px 600px at 20% -10%, rgba(80,120,255,.25), transparent 60%),
                  radial-gradient(900px 500px at 80% 0%, rgba(160,90,255,.18), transparent 55%),
                  var(--bg);
      color:var(--text);
    }

    header{
      position:relative;
      background: rgba(11,15,26,.72);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:12px 16px}
    .top{display:flex; align-items:center; justify-content:space-between; gap:12px}
    h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.2px}

    .controls{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
    }
    select, button{
      height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(18,26,43,.9);
      color:var(--text);
      padding:0 12px;
      outline:none;
    }
    button{
      cursor:pointer;
      background: linear-gradient(180deg, rgba(40,120,255,.9), rgba(30,90,210,.9));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 8px 18px rgba(30,90,210,.25);
    }
    button:active{transform: translateY(1px)}

    main{max-width:1100px;margin:0 auto;padding:10px 16px 60px}

    /* ===== ピラミッド + ベンチ：まとめて sticky ===== */
    .stickyWrap{
      position: sticky;
      top: 0;
      z-index: 30;
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .panel{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 8px 10px 10px;
    }
    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 0 0 6px;
      color: var(--muted);
      font-size: 12px;
    }
    .bar strong{color:var(--text); font-weight:900}
    .mini{
      height:30px;
      padding:0 10px;
      border-radius:10px;
      background: rgba(255,255,255,.06);
      border:1px solid var(--line);
      box-shadow:none;
      cursor:pointer;
      color: var(--text);
    }

    /* ===== 表示項目トグル ===== */
    .toggles{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin: 6px 0 2px;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size: 12px;
      user-select:none;
    }
    .chip input{ accent-color: #7fb6ff; }

    /* ===== ピラミッド ===== */
    .rows{display:flex; flex-direction:column; gap:6px}
    .row{
      display:flex;
      justify-content:center;
      gap: var(--gap);
      flex-wrap: nowrap;
      width: 100%;
    }

    .slotWrap{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
      width: var(--slotSize);
      flex: 0 0 auto;
    }
    .slot{
      width: var(--slotSize);
      aspect-ratio: 1 / 1;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(255,255,255,.05);
      border: none;
      box-shadow: none;
      position: relative;
      touch-action: manipulation;
      cursor:pointer;
    }
    .slot img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      border-radius:999px;
    }
    .slot.active{
      outline: 2px solid rgba(110,190,255,.85);
      outline-offset: 2px;
    }
    .slot.empty{
      background: rgba(255,255,255,.04);
      border: 1px dashed rgba(255,255,255,.14);
    }

    /* ピラミッドに出すテキスト（ONの時だけ描画） */
    .slotInfo{
      width: 100%;
      text-align:center;
      font-size: 10px;
      color: rgba(232,238,252,.92);
      line-height: 1.15;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .slotInfo .line{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* ===== ベンチ ===== */
    .benchRow{
      display:flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 2px;
      -webkit-overflow-scrolling: touch;
    }
    .benchItemWrap{
      width: var(--benchSize);
      flex: 0 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
    }
    .benchItem{
      width: var(--benchSize);
      aspect-ratio:1/1;
      border-radius:999px;
      overflow:hidden;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      cursor:pointer;
      position:relative;
      touch-action: manipulation;
    }
    .benchItem img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }

    .benchInfo{
      width:100%;
      text-align:center;
      font-size: 10px;
      color: rgba(232,238,252,.9);
      line-height: 1.1;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .benchInfo .line{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    /* ===== 一覧 ===== */
    .gridSection{margin-top: 12px}
    .grid{
      display:grid;
      gap:10px;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    }
    @media (max-width: 1100px){
      .grid{ grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 360px){
      .grid{ grid-template-columns: repeat(3, 1fr); }
    }
    .card{
      position:relative;
      background: linear-gradient(180deg, rgba(18,26,43,.9), rgba(15,22,38,.92));
      border:1px solid var(--line);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, border-color .12s ease, filter .12s ease;
    }
    .card:hover{transform: translateY(-2px)}
    .thumb{
      aspect-ratio: 1 / 1;
      width:100%;
      background: rgba(255,255,255,.06);
      display:block;
      object-fit: cover;
    }
    .meta{padding:8px 8px 10px}
    .name{font-size:13px;font-weight:900;line-height:1.2;margin:0 0 4px}
    .sub{font-size:11px;color:var(--muted);margin:0}

    .card.selected{
      border-color: rgba(110,190,255,.85);
      filter: saturate(1.05);
      box-shadow: 0 0 0 2px rgba(110,190,255,.22), var(--shadow);
    }
    .idx{
      position:absolute;
      top:8px; left:8px;
      height:20px;
      padding:0 7px;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      font-size:11px;
      font-weight:900;
      color:rgba(255,255,255,.95);
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
    }
    .card.pickTarget{
      outline: 2px solid rgba(110,190,255,.55);
      outline-offset: 2px;
    }
  </style>
</head>

<body>
  <header>
    <div class="wrap">
      <div class="top">
        <h1>Produce101 11人ピラミッドメーカー</h1>
        <div class="controls">
          <select id="sort">
            <option value="registered">登録順</option>
            <option value="name_asc">名前 A→Z</option>
            <option value="name_desc">名前 Z→A</option>

            <!-- ★追加：スロット順（ピラミッド順） -->
            <option value="slot_order">スロット順</option>
          </select>
          <button id="reload" type="button">データ再読込</button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <section class="stickyWrap">
      <div class="panel">
        <div class="bar">
          <div id="count"></div>
          <button class="mini" id="clear" type="button">全解除</button>
        </div>

        <!-- ★追加：ピラミッド/ベンチに出す項目 -->
        <div class="toggles" id="toggles"></div>

        <div class="rows" id="pyramid"></div>
      </div>

      <div class="panel">
        <div class="bar">
          <div><strong>ベンチ</strong> <span id="benchCount"></span></div>
          <div></div>
        </div>
        <div class="benchRow" id="bench"></div>
      </div>
    </section>

    <section class="gridSection">
      <div class="grid" id="grid"></div>
    </section>
  </main>

  <script>
    const CSV_PATH = "data/master.csv";

    const gridEl = document.getElementById("grid");
    const sortEl = document.getElementById("sort");
    const countEl = document.getElementById("count");
    const pyramidEl = document.getElementById("pyramid");
    const benchEl = document.getElementById("bench");
    const benchCountEl = document.getElementById("benchCount");
    const togglesEl = document.getElementById("toggles");

    const ROWS = [1,2,3,5];
    const TOTAL = ROWS.reduce((a,b)=>a+b,0);

    // ★表示可能フィールド（CSV列名が無くても空なら出ない）
    // ここに増やせば増やせる（例：weight, blood, team…）
    const DISPLAY_FIELDS = [
      { key: "name",    label: "名前" },
      { key: "birth",   label: "生年/生年月日" },
      { key: "origin",  label: "出身地" },
      { key: "height",  label: "身長" },
      { key: "romaji",  label: "ローマ字" },
    ];

    const state = {
      people: [],
      byId: new Map(),
      lastSortedIds: [],
      slots: Array(TOTAL).fill(null),
      bench: [],
      activeSlotIndex: null,

      // ★表示ON/OFF（初期は全部OFF：顔だけ）
      show: {
        name:false,
        birth:false,
        origin:false,
        height:false,
        romaji:false,
      },
    };

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }

    function splitCsvLine(line){
      const out = [];
      let cur = "";
      let inQ = false;
      for (let i=0;i<line.length;i++){
        const c = line[i];
        if (c === '"'){
          if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = !inQ;
        } else if (c === "," && !inQ){
          out.push(cur); cur = "";
        } else {
          cur += c;
        }
      }
      out.push(cur);
      return out;
    }

    function parseCsv(text){
      const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.trim() !== "");
      if (!lines.length) return [];
      const header = splitCsvLine(lines[0]).map(h => h.trim());
      const rows = [];
      for (let i=1;i<lines.length;i++){
        const cols = splitCsvLine(lines[i]);
        const obj = {};
        for (let j=0;j<header.length;j++){
          obj[header[j]] = (cols[j] ?? "").trim();
        }
        rows.push(obj);
      }
      return rows;
    }

    function pickField(obj, keys){
      for (const k of keys){
        if (obj[k] != null && String(obj[k]).trim() !== "") return String(obj[k]).trim();
      }
      return "";
    }

    function normalizePeople(rows){
      return rows.map((r, idx) => {
        const id = pickField(r, ["id","ID","Id"]) || String(idx+1);
        const name = pickField(r, ["name","Name","名前","氏名"]);
        const romaji = pickField(r, ["romaji","Romaji","roman","ローマ字"]);
        const birth = pickField(r, ["birth","birthYear","year","生年","生年月日","誕生日","生年月日(西暦)"]);
        const origin = pickField(r, ["origin","出身地","出身","city","pref","prefecture"]);
        const height = pickField(r, ["height","身長","height_cm","身長(cm)"]);
        const img  = pickField(r, ["img","image","Image","画像","photo","Photo"]);
        return { id, name, romaji, birth, origin, height, img, __idx: idx };
      });
    }

    function slotCount(){ return state.slots.filter(Boolean).length; }
    function isInSlots(id){ return state.slots.includes(id); }
    function isInBench(id){ return state.bench.includes(id); }
    function isSelected(id){ return isInSlots(id) || isInBench(id); }

    function removeIdEverywhere(id){
      const si = state.slots.indexOf(id);
      if (si >= 0) state.slots[si] = null;
      const bi = state.bench.indexOf(id);
      if (bi >= 0) state.bench.splice(bi, 1);
    }
    function firstEmptySlot(){ return state.slots.findIndex(x => !x); }
    function swapSlots(a, b){
      const tmp = state.slots[a];
      state.slots[a] = state.slots[b];
      state.slots[b] = tmp;
    }

    function placeIdIntoSlot(id, slotIndex){
      if (state.slots[slotIndex] === id) return;

      const from = state.slots.indexOf(id);
      if (from >= 0){
        swapSlots(from, slotIndex);
        return;
      }

      const bi = state.bench.indexOf(id);
      if (bi >= 0){
        const occupant = state.slots[slotIndex];
        state.slots[slotIndex] = id;
        state.bench.splice(bi, 1);
        if (occupant) state.bench.unshift(occupant);
        return;
      }

      const occupant = state.slots[slotIndex];
      state.slots[slotIndex] = id;
      if (occupant) state.bench.unshift(occupant);
    }

    // ===== 表示トグルUI =====
    function renderToggles(){
      togglesEl.innerHTML = DISPLAY_FIELDS.map(f => {
        const checked = state.show[f.key] ? "checked" : "";
        return `
          <label class="chip">
            <input type="checkbox" data-key="${escapeHtml(f.key)}" ${checked}>
            ${escapeHtml(f.label)}
          </label>
        `;
      }).join("");
    }

    togglesEl.addEventListener("change", (e) => {
      const cb = e.target.closest("input[type=checkbox]");
      if (!cb) return;
      const key = cb.dataset.key;
      state.show[key] = cb.checked;

      // ピラミッド/ベンチの表示だけ更新（一覧はそのまま）
      renderPyramid();
      renderBench();
    });

    // ===== ピラミッド/ベンチに出す行を生成 =====
    function buildInfoLines(p){
      if (!p) return [];
      const lines = [];
      for (const f of DISPLAY_FIELDS){
        if (!state.show[f.key]) continue;
        const val = p[f.key];
        if (!val) continue;
        lines.push(val);
      }
      return lines;
    }

    function setBar(){
      const n = slotCount();
      countEl.innerHTML = n ? `<strong>${n}</strong> / ${TOTAL}` : "";
      benchCountEl.textContent = state.bench.length ? `（${state.bench.length}）` : "";
    }

    function renderPyramid(){
      let cursor = 0;
      const rowsHtml = ROWS.map(n => {
        const items = [];
        for (let i=0;i<n;i++){
          const idx = cursor++;
          const id = state.slots[idx];
          const p = id ? state.byId.get(id) : null;
          const imgSrc = p?.img ? escapeHtml(p.img) : "";
          const lines = buildInfoLines(p);

          const slotCls = [
            "slot",
            id ? "" : "empty",
            state.activeSlotIndex === idx ? "active" : ""
          ].filter(Boolean).join(" ");

          items.push(`
            <div class="slotWrap">
              <div class="${slotCls}" data-slot="${idx}" role="button" tabindex="0">
                ${id && imgSrc ? `<img src="${imgSrc}" alt="" loading="lazy" />` : ``}
              </div>
              ${lines.length ? `
                <div class="slotInfo">
                  ${lines.slice(0,3).map(t => `<div class="line">${escapeHtml(t)}</div>`).join("")}
                </div>
              ` : ``}
            </div>
          `);
        }
        return `<div class="row">${items.join("")}</div>`;
      }).join("");

      pyramidEl.innerHTML = rowsHtml;
      setBar();
    }

    function renderBench(){
      const html = state.bench.map(id => {
        const p = state.byId.get(id);
        const imgSrc = p?.img ? escapeHtml(p.img) : "";
        const lines = buildInfoLines(p);

        return `
          <div class="benchItemWrap">
            <div class="benchItem" data-id="${escapeHtml(id)}" role="button" tabindex="0" title="${escapeHtml(p?.name || "")}">
              ${imgSrc ? `<img src="${imgSrc}" alt="" loading="lazy" />` : ``}
            </div>
            ${lines.length ? `
              <div class="benchInfo">
                ${lines.slice(0,2).map(t => `<div class="line">${escapeHtml(t)}</div>`).join("")}
              </div>
            ` : ``}
          </div>
        `;
      }).join("");

      benchEl.innerHTML = html;
      setBar();
    }

    // ===== 並び替え =====
    // 追加：スロット順（= ピラミッドの並びを最上位に）
    // - ピラミッド枠にいる子 → 上から順に先頭に来る
    // - ベンチにいる子 → bench配列の順
    // - 未選択 → その後（登録順）
    function getSlotOrderRankMap(){
      const map = new Map();
      let r = 0;
      for (const id of state.slots){
        if (!id) continue;
        if (!map.has(id)) map.set(id, r++);
      }
      for (const id of state.bench){
        if (!map.has(id)) map.set(id, r++);
      }
      return map;
    }

    function getSortedPeople(){
      const arr = [...state.people];
      const mode = sortEl.value;

      if (mode === "registered"){
        arr.sort((a,b) => a.__idx - b.__idx);
      } else if (mode === "name_asc"){
        arr.sort((a,b) => (a.name || "").localeCompare(b.name || "", "ja"));
      } else if (mode === "name_desc"){
        arr.sort((a,b) => (b.name || "").localeCompare(a.name || "", "ja"));
      } else if (mode === "slot_order"){
        const rank = getSlotOrderRankMap();
        arr.sort((a,b) => {
          const ra = rank.has(a.id) ? rank.get(a.id) : 1e9 + a.__idx;
          const rb = rank.has(b.id) ? rank.get(b.id) : 1e9 + b.__idx;
          return ra - rb;
        });
      }

      state.lastSortedIds = arr.map(p => p.id);
      return arr;
    }

    function renderGrid(){
      const arr = getSortedPeople();
      const active = state.activeSlotIndex != null;

      const html = arr.map((p, i) => {
        const selected = isSelected(p.id) ? "selected" : "";
        const pickTarget = active ? "pickTarget" : "";
        const imgSrc = p.img ? escapeHtml(p.img) : "";
        const name = escapeHtml(p.name || "");
        const sub = escapeHtml([p.romaji, p.birth, p.origin, p.height].filter(Boolean).join(" / "));
        const idx = i + 1;

        return `
          <div class="card ${selected} ${pickTarget}" data-id="${escapeHtml(p.id)}" role="button" tabindex="0" aria-label="${name}">
            <span class="idx">${idx}</span>
            ${imgSrc
              ? `<img class="thumb" src="${imgSrc}" alt="${name}" loading="lazy"
                   onerror="this.style.display='none'; this.insertAdjacentHTML('afterend','<div style=&quot;aspect-ratio:1/1;background:rgba(255,255,255,.06);display:block&quot;></div>')" />`
              : `<div style="aspect-ratio:1/1;background:rgba(255,255,255,.06);display:block"></div>`
            }
            <div class="meta">
              <p class="name">${name}</p>
              <p class="sub">${sub}</p>
            </div>
          </div>
        `;
      }).join("");

      gridEl.innerHTML = html;
      setBar();
    }

    // ===== 操作 =====
    function onSlotClick(slotIndex){
      const id = state.slots[slotIndex];

      if (state.activeSlotIndex == null){
        state.activeSlotIndex = slotIndex;
        renderPyramid(); renderBench(); renderGrid();
        return;
      }

      if (state.activeSlotIndex === slotIndex){
        if (id) state.slots[slotIndex] = null;
        state.activeSlotIndex = null;
        renderPyramid(); renderBench(); renderGrid();
        return;
      }

      swapSlots(state.activeSlotIndex, slotIndex);
      state.activeSlotIndex = null;
      renderPyramid(); renderBench(); renderGrid();
    }

    function onPickId(id){
      if (state.activeSlotIndex != null){
        placeIdIntoSlot(id, state.activeSlotIndex);
        state.activeSlotIndex = null;
        renderPyramid(); renderBench(); renderGrid();
        return;
      }

      if (isSelected(id)){
        removeIdEverywhere(id);
        renderPyramid(); renderBench(); renderGrid();
        return;
      }

      const empty = firstEmptySlot();
      if (empty >= 0) state.slots[empty] = id;
      else state.bench.unshift(id);

      renderPyramid(); renderBench(); renderGrid();
    }

    // ===== CSV読み込み =====
    async function loadData(){
      const res = await fetch(CSV_PATH, { cache: "no-store" });
      const text = await res.text();
      const rows = parseCsv(text);

      state.people = normalizePeople(rows);
      state.byId = new Map(state.people.map(p => [p.id, p]));

      state.slots = state.slots.map(id => (id && state.byId.has(id)) ? id : null);
      state.bench = state.bench.filter(id => state.byId.has(id));
      state.activeSlotIndex = null;

      renderToggles();
      renderPyramid(); renderBench(); renderGrid();
    }

    // ===== Events =====
    pyramidEl.addEventListener("click", (e) => {
      const slot = e.target.closest(".slot");
      if (!slot) return;
      onSlotClick(Number(slot.dataset.slot));
    });
    pyramidEl.addEventListener("keydown", (e) => {
      if (e.key !== "Enter" && e.key !== " ") return;
      const slot = e.target.closest(".slot");
      if (!slot) return;
      e.preventDefault();
      onSlotClick(Number(slot.dataset.slot));
    });

    benchEl.addEventListener("click", (e) => {
      const item = e.target.closest(".benchItem");
      if (!item) return;
      onPickId(item.dataset.id);
    });
    benchEl.addEventListener("keydown", (e) => {
      if (e.key !== "Enter" && e.key !== " ") return;
      const item = e.target.closest(".benchItem");
      if (!item) return;
      e.preventDefault();
      onPickId(item.dataset.id);
    });

    gridEl.addEventListener("click", (e) => {
      const card = e.target.closest(".card");
      if (!card) return;
      onPickId(card.dataset.id);
    });
    gridEl.addEventListener("keydown", (e) => {
      if (e.key !== "Enter" && e.key !== " ") return;
      const card = e.target.closest(".card");
      if (!card) return;
      e.preventDefault();
      onPickId(card.dataset.id);
    });

    sortEl.addEventListener("change", renderGrid);
    document.getElementById("reload").addEventListener("click", loadData);

    document.getElementById("clear").addEventListener("click", () => {
      state.slots = Array(TOTAL).fill(null);
      state.bench = [];
      state.activeSlotIndex = null;
      renderPyramid(); renderBench(); renderGrid();
    });

    // init
    renderToggles();
    renderPyramid();
    renderBench();
    loadData();
  </script>
</body>
</html>
