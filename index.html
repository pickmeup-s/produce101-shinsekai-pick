<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>日プ新世界 ピラミッドメーカー</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --panel:#121a2b;

      --text:#e8eefc;
      --muted:#a9b6d6;
      --line:rgba(255,255,255,.12);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --r:14px;

      --gap:6px;

      /* JSで内幅から決定（はみ出し防止） */
      --slotSize: 64px;
      --slotMax: 92px;

      --benchSize: 46px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(80,120,255,.25), transparent 60%),
        radial-gradient(900px 500px at 80% 0%, rgba(160,90,255,.18), transparent 55%),
        var(--bg);
      color:var(--text);
    }

    header{
      background: rgba(11,15,26,.72);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:12px 16px}
    h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.2px}

    button{
      height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:0 12px;
      cursor:pointer;
      box-shadow:none;
    }
    button:active{transform: translateY(1px)}

    .arrowBtn{
      width:32px;
      height:32px;
      padding:0;
      border-radius:10px;
      font-size:16px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    main{max-width:1100px;margin:0 auto;padding:10px 16px 60px}

    /* スクロールで流れてOKな上部コマンド */
    .topControls{
      margin-top: 10px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:space-between;
    }
    .topLeft{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size: 12px;
      user-select:none;
      white-space:nowrap;
    }
    .chip input{ accent-color: #7fb6ff; }

    /* sticky: ピラミッド＋ベンチだけ固定 */
    .stickyWrap{
      position: sticky;
      top: 0;
      z-index: 30;
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .panel{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: 8px 6px 10px;
    }

    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin: 0 0 6px;
      color: var(--muted);
      font-size: 12px;
    }
    .bar strong{color:var(--text); font-weight:900}

    /* pyramid */
    #pyramidPanel{
      /* “画面が圧迫”対策：高さを半分までに抑える */
      max-height: 50vh;
      overflow: auto;
    }

    .rows{display:flex; flex-direction:column; gap:8px}
    .row{
      display:flex;
      justify-content:center;
      gap: var(--gap);
      width: 100%;
      flex-wrap: nowrap;
    }
    .slotWrap{
      width: var(--slotSize);
      flex: 0 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
    }
    .slot{
      width: var(--slotSize);
      aspect-ratio: 1 / 1;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(255,255,255,.05);
      border: 2px solid transparent;
      cursor:pointer;
      touch-action: manipulation;
    }
    .slot img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      border-radius:999px;
    }
    .slot.active{
      outline: 2px solid rgba(110,190,255,.85);
      outline-offset: 0px;
    }
    .slot.empty{
      background: rgba(255,255,255,.04);
      border: 1px dashed rgba(255,255,255,.14);
    }

    .slotInfo{
      width: 100%;
      text-align:center;
      line-height: 1.15;
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .slotInfo .line{
      white-space: normal;
      word-break: break-word;
      overflow: hidden;
      text-overflow: clip;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      font-size: clamp(8px, 2.6vw, 10px);
      color: rgba(232,238,252,.92);
    }

    /* bench */
    #benchPanel{
      max-height: 24vh;
      overflow: hidden;
    }
    .benchRow{
      display:flex;
      gap: 10px;
      overflow-x: auto;
      padding-bottom: 2px;
      -webkit-overflow-scrolling: touch;
    }
    .benchItemWrap{
      width: var(--benchSize);
      flex: 0 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
    }
    .benchItem{
      width: var(--benchSize);
      aspect-ratio:1/1;
      border-radius:999px;
      overflow:hidden;
      background: rgba(255,255,255,.05);
      border: 2px solid rgba(255,255,255,.10);
      cursor:pointer;
      touch-action: manipulation;
    }
    .benchItem img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .benchItem.activeBench{
      outline: 2px solid rgba(110,190,255,.85);
      outline-offset: 0px;
    }
    .benchItem.pendingDelete{
      outline: 2px solid rgba(255,200,90,.95);
      outline-offset: 0px;
    }

    /* ベンチ折りたたみ：写真も文字も丸ごと隠す */
    .benchCollapsed .benchRow{ display:none; }
    .benchCollapsed .bar{ margin-bottom:0; }
    .benchCollapsed{ padding-bottom:8px; }

    /* options (スクロールで流れる) */
    .optionsPanel{
      margin-top: 12px;
      background: rgba(255,255,255,.05);
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 10px;
    }
    .optionsTitle{
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 8px;
    }
    .toggles{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      max-height: 120px;
      overflow:auto;
      padding-right:4px;
      margin-bottom: 10px;
    }
    .chipToggle{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-size: 12px;
      user-select:none;
      white-space:nowrap;
    }
    .chipToggle input{ accent-color: #7fb6ff; }
    .chipToggle input:disabled{ opacity:.5; }

    .sortBox{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    select{
      height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(18,26,43,.95);
      color:var(--text);
      padding:0 12px;
      outline:none;
    }

    /* grid */
    .gridSection{margin-top: 12px}
    .grid{
      display:grid;
      gap:10px;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    }
    @media (max-width: 1100px){
      .grid{ grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 360px){
      .grid{ grid-template-columns: repeat(3, 1fr); }
    }
    .card{
      position:relative;
      background: linear-gradient(180deg, rgba(18,26,43,.95), rgba(15,22,38,.96));
      border:2px solid rgba(255,255,255,.10);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease, border-color .12s ease, filter .12s ease;
    }
    .card:hover{transform: translateY(-2px)}
    .thumb{
      aspect-ratio: 1 / 1;
      width:100%;
      background: rgba(255,255,255,.06);
      display:block;
      object-fit: cover;
    }
    .meta{padding:8px 8px 10px}
    .name{font-size:13px;font-weight:900;line-height:1.2;margin:0 0 4px}
    .sub{font-size:11px;color:var(--muted);margin:0}

    .card.selected{
      border-color: rgba(110,190,255,.85);
      filter: saturate(1.05);
      box-shadow: 0 0 0 2px rgba(110,190,255,.18), var(--shadow);
    }
    .card.pendingDelete{
      border-color: rgba(255,200,90,.95);
      box-shadow: 0 0 0 2px rgba(255,200,90,.18), var(--shadow);
    }

    .idx{
      position:absolute;
      top:8px; left:8px;
      height:20px;
      padding:0 7px;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      font-size:11px;
      font-weight:900;
      color:rgba(255,255,255,.95);
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <h1>日プ新世界 ピラミッドメーカー</h1>
  </div>
</header>

<main>
  <!-- スクロールで流れてOK -->
  <div class="topControls">
    <div class="topLeft">
      <button id="clear" type="button">全解除</button>
      <label class="chip">
        <input id="frameToggle" type="checkbox">
        枠色（シグナルソングクラス）
      </label>
    </div>
    <div></div>
  </div>

  <section class="stickyWrap">
    <div class="panel" id="pyramidPanel">
      <div class="rows" id="pyramid"></div>
    </div>

    <div class="panel" id="benchPanel">
      <div class="bar">
        <div><strong>ベンチ</strong> <span id="benchCount"></span></div>
        <button id="toggleBench" type="button" class="arrowBtn">▾</button>
      </div>
      <div class="benchRow" id="bench"></div>
    </div>
  </section>

  <section class="optionsPanel">
    <p class="optionsTitle">表示する項目（３つまで）</p>
    <div class="toggles" id="toggles"></div>

    <div class="sortBox">
      <select id="sortKey"></select>
      <select id="sortDir">
        <option value="asc">昇順</option>
        <option value="desc">降順</option>
      </select>
    </div>
  </section>

  <section class="gridSection">
    <div class="grid" id="grid"></div>
  </section>
</main>

<script>
  const CSV_PATH = "data/master.csv";
  const STORAGE_KEY = "pyramid_maker_state_v2";

  const gridEl = document.getElementById("grid");
  const pyramidEl = document.getElementById("pyramid");
  const benchEl = document.getElementById("bench");
  const benchCountEl = document.getElementById("benchCount");
  const togglesEl = document.getElementById("toggles");
  const pyramidPanelEl = document.getElementById("pyramidPanel");
  const benchPanelEl = document.getElementById("benchPanel");

  const sortKeyEl = document.getElementById("sortKey");
  const sortDirEl = document.getElementById("sortDir");

  const clearBtn = document.getElementById("clear");
  const frameToggleEl = document.getElementById("frameToggle");
  const benchToggleBtn = document.getElementById("toggleBench");

  const ROWS = [1,2,3,5];
  const TOTAL = ROWS.reduce((a,b)=>a+b,0);

  const EXCLUDE_KEYS = new Set([
    "id","ID","Id",
    "img","image","Image","画像","photo","Photo",
    "__idx"
  ]);

  const CLASS_COL = "シグナルソングクラス";
  const CLASS_COL_ALT = "signal_class";

  const CLASS_COLOR = {
    "A":"#ff69b4",
    "B":"#ffa500",
    "C":"#7fffd4",
    "D":"#080000",
    "F":"#d3d3d3"
  };

  const state = {
    header: [],
    people: [],
    byId: new Map(),

    slots: Array(TOTAL).fill(null),
    bench: [],

    activeSlotIndex: null,
    activeBenchIndex: null,

    displayKeys: [],
    show: {},

    sortKeys: [],

    lastTappedId: null,

    benchCollapsed: false,
    classFrameOn: false,
  };

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

  function splitCsvLine(line){
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i=0;i<line.length;i++){
      const c = line[i];
      if (c === '"'){
        if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if (c === "," && !inQ){
        out.push(cur); cur = "";
      } else {
        cur += c;
      }
    }
    out.push(cur);
    return out;
  }

  function parseCsvWithHeader(text){
    const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.trim() !== "");
    if (!lines.length) return { header: [], rows: [] };
    const header = splitCsvLine(lines[0]).map(h => h.trim());
    const rows = [];
    for (let i=1;i<lines.length;i++){
      const cols = splitCsvLine(lines[i]);
      const obj = {};
      for (let j=0;j<header.length;j++){
        obj[header[j]] = (cols[j] ?? "").trim();
      }
      rows.push(obj);
    }
    return { header, rows };
  }

  function pickField(obj, keys){
    for (const k of keys){
      if (obj[k] != null && String(obj[k]).trim() !== "") return String(obj[k]).trim();
    }
    return "";
  }

  function normalizePeople(rows){
    return rows.map((r, idx) => {
      const id = pickField(r, ["id","ID","Id"]) || String(idx+1);
      const img  = pickField(r, ["img","image","Image","画像","photo","Photo"]);
      return { id, img, raw: r, __idx: idx };
    });
  }

  function isInSlots(id){ return state.slots.includes(id); }
  function isInBench(id){ return state.bench.includes(id); }
  function isSelected(id){ return isInSlots(id) || isInBench(id); }

  function removeIdEverywhere(id){
    const si = state.slots.indexOf(id);
    if (si >= 0) state.slots[si] = null;
    const bi = state.bench.indexOf(id);
    if (bi >= 0) state.bench.splice(bi, 1);
  }

  function firstEmptySlot(){ return state.slots.findIndex(x => !x); }

  function swapSlots(a, b){
    const tmp = state.slots[a];
    state.slots[a] = state.slots[b];
    state.slots[b] = tmp;
  }

  function swapSlotWithBench(slotIndex, benchIndex){
    const slotId = state.slots[slotIndex] || null;
    const benchId = state.bench[benchIndex] || null;
    if (!benchId) return;

    state.slots[slotIndex] = benchId;

    if (slotId){
      state.bench[benchIndex] = slotId;   // 場所だけ入替（順番は変えない）
    } else {
      state.bench.splice(benchIndex, 1);  // 空枠ならベンチだけ消える
    }
  }

  function getClassColor(person){
    if (!person) return "";
    const cls = (person.raw?.[CLASS_COL] || person.raw?.[CLASS_COL_ALT] || "").trim();
    return CLASS_COLOR[cls] || "";
  }

  function updateSlotSize(){
    if (!pyramidPanelEl) return;

    const st = getComputedStyle(pyramidPanelEl);
    const padL = parseFloat(st.paddingLeft) || 0;
    const padR = parseFloat(st.paddingRight) || 0;
    const inner = Math.max(0, pyramidPanelEl.clientWidth - padL - padR);

    const root = getComputedStyle(document.documentElement);
    const gap = parseFloat(root.getPropertyValue("--gap")) || 6;
    const slotMax = parseFloat(root.getPropertyValue("--slotMax")) || 92;

    const size = Math.min(slotMax, Math.floor((inner - (4 * gap)) / 5));
    document.documentElement.style.setProperty("--slotSize", Math.max(52, size) + "px");
  }

  function buildDisplayKeysFromHeader(header){
    return header.filter(h => h && !EXCLUDE_KEYS.has(h));
  }

  function selectedToggleCount(){
    let c = 0;
    for (const k of state.displayKeys){
      if (state.show[k]) c++;
    }
    return c;
  }

  function renderToggles(){
    const picked = selectedToggleCount();
    const max = 3;
    const disableNew = picked >= max;

    togglesEl.innerHTML = state.displayKeys.map(key => {
      const checked = state.show[key] ? "checked" : "";
      const disabled = (!state.show[key] && disableNew) ? "disabled" : "";
      return `
        <label class="chipToggle">
          <input type="checkbox" data-key="${escapeHtml(key)}" ${checked} ${disabled}>
          ${escapeHtml(key)}
        </label>
      `;
    }).join("");
  }

  togglesEl.addEventListener("change", (e) => {
    const cb = e.target.closest("input[type=checkbox]");
    if (!cb) return;

    const key = cb.dataset.key;
    const currentlyOn = selectedToggleCount();

    if (!state.show[key] && cb.checked && currentlyOn >= 3){
      cb.checked = false;
      return;
    }

    state.show[key] = cb.checked;

    renderToggles();
    renderPyramid();
    renderBench();
    renderGrid();
    persistSoon();
  });

  frameToggleEl.addEventListener("change", () => {
    state.classFrameOn = frameToggleEl.checked;
    renderPyramid();
    renderBench();
    renderGrid();
    persistSoon();
  });

  function buildInfoLines(person){
    if (!person) return [];
    const r = person.raw || {};
    const lines = [];
    for (const key of state.displayKeys){
      if (!state.show[key]) continue;
      const v = (r[key] ?? "").trim();
      if (!v) continue;
      lines.push(v);
      if (lines.length >= 3) break;
    }
    return lines;
  }

  function buildSortKeys(header){
    const excludeForSort = new Set(["img","image","Image","画像","photo","Photo"]);
    return header.filter(h => h && !excludeForSort.has(h));
  }

  function renderSortSelect(){
    sortKeyEl.innerHTML = state.sortKeys.map(k =>
      `<option value="${escapeHtml(k)}">${escapeHtml(k)}</option>`
    ).join("");

    if (state.sortKeys.includes("Name")) sortKeyEl.value = "Name";
    else if (state.sortKeys.includes("名前")) sortKeyEl.value = "名前";
    else sortKeyEl.value = state.sortKeys[0] || "";
  }

  function toSortableValue(v){
    const s = String(v ?? "").trim();
    const n = Number(s);
    if (s !== "" && Number.isFinite(n)) return { type:"num", v:n };
    return { type:"str", v:s };
  }

  function getSortedPeople(){
    const arr = [...state.people];
    const key = sortKeyEl.value;
    const dir = sortDirEl.value;

    arr.sort((a,b) => {
      const av = toSortableValue(a.raw[key]);
      const bv = toSortableValue(b.raw[key]);

      let cmp = 0;
      if (av.type === "num" && bv.type === "num") cmp = av.v - bv.v;
      else cmp = String(av.v).localeCompare(String(bv.v), "ja", { numeric:true, sensitivity:"base" });

      return dir === "desc" ? -cmp : cmp;
    });

    return arr;
  }

  function renderPyramid(){
    let cursor = 0;

    pyramidEl.innerHTML = ROWS.map(n => {
      const items = [];
      for (let i=0;i<n;i++){
        const idx = cursor++;
        const id = state.slots[idx];
        const p = id ? state.byId.get(id) : null;
        const imgSrc = p?.img ? escapeHtml(p.img) : "";
        const lines = buildInfoLines(p);

        const frameColor = (state.classFrameOn ? getClassColor(p) : "");
        const style = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

        const slotCls = [
          "slot",
          id ? "" : "empty",
          state.activeSlotIndex === idx ? "active" : ""
        ].filter(Boolean).join(" ");

        items.push(`
          <div class="slotWrap">
            <div class="${slotCls}" ${style} data-slot="${idx}" role="button" tabindex="0">
              ${id && imgSrc ? `<img src="${imgSrc}" alt="" loading="lazy" />` : ``}
            </div>
            ${lines.length ? `
              <div class="slotInfo">
                ${lines.map(t => `<div class="line">${escapeHtml(t)}</div>`).join("")}
              </div>
            ` : ``}
          </div>
        `);
      }
      return `<div class="row">${items.join("")}</div>`;
    }).join("");
  }

  function renderBench(){
    benchPanelEl.classList.toggle("benchCollapsed", state.benchCollapsed);
    benchToggleBtn.textContent = state.benchCollapsed ? "▴" : "▾";
    benchCountEl.textContent = state.bench.length ? `（${state.bench.length}）` : "";

    if (state.benchCollapsed){
      benchEl.innerHTML = "";
      return;
    }

    benchEl.innerHTML = state.bench.map((id, i) => {
      const p = state.byId.get(id);
      const imgSrc = p?.img ? escapeHtml(p.img) : "";
      const frameColor = (state.classFrameOn ? getClassColor(p) : "");
      const style = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

      const activeCls = (state.activeBenchIndex === i) ? "activeBench" : "";
      const delCls = (state.lastTappedId === id) ? "pendingDelete" : "";

      return `
        <div class="benchItemWrap">
          <div class="benchItem ${activeCls} ${delCls}" ${style} data-index="${i}" data-id="${escapeHtml(id)}" role="button" tabindex="0">
            ${imgSrc ? `<img src="${imgSrc}" alt="" loading="lazy" />` : ``}
          </div>
        </div>
      `;
    }).join("");
  }

  function getCardTitleAndSub(person){
    const lines = buildInfoLines(person);

    const fallbackNameKey = state.header.includes("Name") ? "Name"
      : state.header.includes("名前") ? "名前"
      : null;

    const title = lines[0] || (fallbackNameKey ? (person.raw[fallbackNameKey] || "") : "");
    const sub = lines.slice(1,3).join(" / ");

    return { title, sub };
  }

  function renderGrid(){
    const arr = getSortedPeople();

    gridEl.innerHTML = arr.map((p, i) => {
      const selected = isSelected(p.id) ? "selected" : "";
      const pendingDelete = (state.lastTappedId === p.id) ? "pendingDelete" : "";
      const imgSrc = p.img ? escapeHtml(p.img) : "";

      const frameColor = (state.classFrameOn ? getClassColor(p) : "");
      const borderStyle = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

      const { title, sub } = getCardTitleAndSub(p);
      const idx = i + 1;

      return `
        <div class="card ${selected} ${pendingDelete}" ${borderStyle} data-id="${escapeHtml(p.id)}" role="button" tabindex="0">
          <span class="idx">${idx}</span>
          ${
            imgSrc
              ? `<img class="thumb" src="${imgSrc}" alt="${escapeHtml(title)}" loading="lazy"
                   onerror="this.style.display='none'; this.insertAdjacentHTML('afterend','<div style=&quot;aspect-ratio:1/1;background:rgba(255,255,255,.06);display:block&quot;></div>')" />`
              : `<div style="aspect-ratio:1/1;background:rgba(255,255,255,.06);display:block"></div>`
          }
          <div class="meta">
            <p class="name">${escapeHtml(title)}</p>
            <p class="sub">${escapeHtml(sub)}</p>
          </div>
        </div>
      `;
    }).join("");
  }

  function onSlotClick(slotIndex){
    const slotId = state.slots[slotIndex] || null;

    if (state.activeBenchIndex != null){
      swapSlotWithBench(slotIndex, state.activeBenchIndex);
      state.activeBenchIndex = null;
      state.activeSlotIndex = null;
      state.lastTappedId = null;
      renderPyramid(); renderBench(); renderGrid();
      persistSoon();
      return;
    }

    if (state.activeSlotIndex === slotIndex){
      if (slotId) state.slots[slotIndex] = null;
      state.activeSlotIndex = null;
      state.lastTappedId = null;
      renderPyramid(); renderBench(); renderGrid();
      persistSoon();
      return;
    }

    if (state.activeSlotIndex != null && state.activeSlotIndex !== slotIndex){
      swapSlots(state.activeSlotIndex, slotIndex);
      state.activeSlotIndex = null;
      state.lastTappedId = null;
      renderPyramid(); renderBench(); renderGrid();
      persistSoon();
      return;
    }

    state.activeSlotIndex = slotIndex;
    state.activeBenchIndex = null;
    state.lastTappedId = slotId;
    renderPyramid(); renderBench(); renderGrid();
  }

  function onPickId(id, fromBench=false, benchIndex=null){
    if (state.lastTappedId === id && isSelected(id)){
      removeIdEverywhere(id);
      state.lastTappedId = null;
      state.activeBenchIndex = null;
      state.activeSlotIndex = null;
      renderPyramid(); renderBench(); renderGrid();
      persistSoon();
      return;
    }

    if (state.activeSlotIndex != null){
      if (fromBench && benchIndex != null){
        swapSlotWithBench(state.activeSlotIndex, benchIndex);
      } else {
        const bi = state.bench.indexOf(id);
        if (bi >= 0){
          swapSlotWithBench(state.activeSlotIndex, bi);
        } else {
          const occupant = state.slots[state.activeSlotIndex] || null;
          state.slots[state.activeSlotIndex] = id;
          if (occupant) state.bench.push(occupant);
        }
      }
      state.activeSlotIndex = null;
      state.activeBenchIndex = null;
      state.lastTappedId = null;
      renderPyramid(); renderBench(); renderGrid();
      persistSoon();
      return;
    }

    state.lastTappedId = id;

    if (!isSelected(id)){
      const empty = firstEmptySlot();
      if (empty >= 0) state.slots[empty] = id;
      else state.bench.push(id);
      state.lastTappedId = null;
      state.activeBenchIndex = null;
      renderPyramid(); renderBench(); renderGrid();
      persistSoon();
      return;
    }

    if (fromBench && benchIndex != null){
      state.activeBenchIndex = benchIndex;
    } else {
      const bi = state.bench.indexOf(id);
      state.activeBenchIndex = (bi >= 0) ? bi : null;
    }

    renderPyramid(); renderBench(); renderGrid();
  }

  // 永続化
  let persistTimer = null;
  function persistSoon(){
    clearTimeout(persistTimer);
    persistTimer = setTimeout(persistNow, 120);
  }

  function persistNow(){
    const payload = {
      slots: state.slots,
      bench: state.bench,
      show: state.show,
      sortKey: sortKeyEl.value,
      sortDir: sortDirEl.value,
      benchCollapsed: state.benchCollapsed,
      classFrameOn: state.classFrameOn,
    };
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }catch(_){}
  }

  function restoreFromStorage(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const p = JSON.parse(raw);

      if (Array.isArray(p.slots)) state.slots = p.slots.slice(0, TOTAL).concat(Array(Math.max(0, TOTAL - p.slots.length)).fill(null)).slice(0, TOTAL);
      if (Array.isArray(p.bench)) state.bench = p.bench.slice();

      if (p && typeof p.show === "object" && p.show){
        state.show = { ...p.show };
      }

      if (typeof p.benchCollapsed === "boolean") state.benchCollapsed = p.benchCollapsed;
      if (typeof p.classFrameOn === "boolean") state.classFrameOn = p.classFrameOn;

      if (typeof p.sortDir === "string") sortDirEl.value = p.sortDir;
      // sortKeyはCSV読み込み後にセット（列があるか確認してから）
      state._savedSortKey = (typeof p.sortKey === "string") ? p.sortKey : null;

    }catch(_){}
  }

  async function loadData(){
    restoreFromStorage();

    const res = await fetch(CSV_PATH, { cache: "no-store" });
    const text = await res.text();
    const { header, rows } = parseCsvWithHeader(text);

    state.header = header;

    state.displayKeys = buildDisplayKeysFromHeader(header);
    // showの整合
    for (const k of state.displayKeys){
      if (!(k in state.show)) state.show[k] = false;
    }
    for (const k of Object.keys(state.show)){
      if (!state.displayKeys.includes(k)) delete state.show[k];
    }

    state.sortKeys = buildSortKeys(header);

    state.people = normalizePeople(rows);
    state.byId = new Map(state.people.map(p => [p.id, p]));

    // 存在しないidは消す
    state.slots = state.slots.map(id => (id && state.byId.has(id)) ? id : null);
    state.bench = state.bench.filter(id => state.byId.has(id));

    // sortKey 復元（列が存在する時だけ）
    renderSortSelect();
    if (state._savedSortKey && state.sortKeys.includes(state._savedSortKey)){
      sortKeyEl.value = state._savedSortKey;
    }
    delete state._savedSortKey;

    // UI復元
    frameToggleEl.checked = state.classFrameOn;

    renderToggles();
    updateSlotSize();
    renderPyramid();
    renderBench();
    renderGrid();

    persistSoon();
  }

  pyramidEl.addEventListener("click", (e) => {
    const slot = e.target.closest(".slot");
    if (!slot) return;
    onSlotClick(Number(slot.dataset.slot));
  });

  benchEl.addEventListener("click", (e) => {
    const item = e.target.closest(".benchItem");
    if (!item) return;
    onPickId(item.dataset.id, true, Number(item.dataset.index));
  });

  gridEl.addEventListener("click", (e) => {
    const card = e.target.closest(".card");
    if (!card) return;
    onPickId(card.dataset.id, false, null);
  });

  sortKeyEl.addEventListener("change", () => { renderGrid(); persistSoon(); });
  sortDirEl.addEventListener("change", () => { renderGrid(); persistSoon(); });

  clearBtn.addEventListener("click", () => {
    state.slots = Array(TOTAL).fill(null);
    state.bench = [];
    state.activeSlotIndex = null;
    state.activeBenchIndex = null;
    state.lastTappedId = null;
    renderPyramid(); renderBench(); renderGrid();
    persistSoon();
  });

  benchToggleBtn.addEventListener("click", () => {
    state.benchCollapsed = !state.benchCollapsed;
    renderBench();
    persistSoon();
  });

  window.addEventListener("resize", () => {
    updateSlotSize();
    renderPyramid();
  });

  loadData();
</script>
</body>
</html>
