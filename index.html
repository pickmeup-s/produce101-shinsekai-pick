<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>日プ新世界 ピラミッドメーカー</title>

  <style>
    :root{
      --bg:#ffffff;
      --panel:#f6f8ff;
      --card:#ffffff;
      --text:#0b1020;
      --muted:#3b4a77;
      --line:rgba(10,35,90,.18);
      --shadow:0 10px 26px rgba(10,35,90,.10);
      --r:14px;

      --accent:#0a60ff;

      --gap:6px;
      --slotSize:72px;
      --slotMax:96px;
      --benchSize: var(--slotSize);

      --ringDark: rgba(10,96,255,.92);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      background:
        radial-gradient(1100px 520px at 50% -10%, rgba(10,96,255,.10), transparent 60%),
        radial-gradient(900px 520px at 85% 0%, rgba(0,200,255,.08), transparent 55%),
        var(--bg);
      color: var(--text);
    }

    header{
      background: rgba(255,255,255,.86);
      border-bottom:1px solid var(--line);
      backdrop-filter: blur(8px);
    }
    .wrap{max-width:1100px;margin:0 auto;padding:12px 16px}
    h1{margin:0;font-size:18px;font-weight:800;letter-spacing:.2px;color:var(--text)}

    button{
      height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(10,96,255,.06);
      color: var(--text);
      padding:0 12px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }
    button:active{transform: translateY(1px)}
    .btnIcon{ width:18px;height:18px; display:inline-block; color: var(--text); }

    .arrowBtn{
      width:32px;height:32px;padding:0;border-radius:10px;
      font-size:16px;display:flex;align-items:center;justify-content:center;
      background: rgba(10,96,255,.06);
    }

    main{max-width:1100px;margin:0 auto;padding:10px 16px 60px}

    .stickyWrap{
      position: sticky;
      top: 0;
      z-index: 30;
      margin-top: 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .panel{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      position: relative;
    }

    /* ===== 11pick panel: paddingをrankBarとbodyで分ける（スクロール時の覗き隙間対策） ===== */
    #pyramidPanel{
      padding: 0;                 /* ここ重要：rankBarの背景が枠までピタッと */
      overflow: hidden;           /* 通常時は覗き防止 */
    }
    .pyramidBody{
      padding: 0 6px 10px;        /* 旧panel padding相当 */
    }

    /* 日付 */
    .rankDate{
      position: absolute;
      right: 10px;
      bottom: 8px;
      color: var(--muted);
      font-size: clamp(10px, 2.8vw, 12px);
      line-height: 1.2;
      user-select: none;
      pointer-events: none;
      white-space: nowrap;
    }
    #pyramidPanel{ padding-bottom: 34px; } /* 日付分ちょい確保（以前より詰め） */
    .rankDatePad{ height: 6px; }           /* 16px → 6px（ここが「日付上の行間」） */

    /* Ranking header */
    .rankBar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;

      font-size: 12px;
      color: var(--muted);

      position: sticky;
      top: 0;
      z-index: 50;

      background: var(--panel);
      border-bottom: 1px solid var(--line);

      padding: 10px 8px 8px;      /* 余白少し詰め */
      border-top-left-radius: var(--r);
      border-top-right-radius: var(--r);
    }
    .rankBar strong{ color: var(--text); font-weight:900; }
    .rankTitlePad{
      padding-left: .5em;
      display:flex;
      gap:10px;
      align-items:baseline;
      flex-wrap:wrap;
      min-width: 0;
    }
    #rankStats{
      color: var(--muted);
      font-size: clamp(10px, 2.8vw, 12px);
      line-height: 1.2;
      white-space: normal;
      word-break: break-word;
    }

    /* ヘッダーと最初の写真の間（詰める） */
    .pyramidTopGap{ height: 6px; }  /* 16 → 6 */

    /* ===== Rings ===== */
    .card.selected,
    .card.activeRing{
      box-shadow: 0 0 0 2px var(--ringDark);
    }
    .slot.activeRing,
    .benchItem.activeRing{
      box-shadow: 0 0 0 2px var(--ringDark);
    }

    /* ===== Pyramid：段の行間を詰める ===== */
    .rows{display:flex; flex-direction:column; gap:5px;} /* 8 → 5 */
    .row{display:flex; justify-content:center; gap: var(--gap); width:100%; flex-wrap:nowrap;}

    .slotWrap{
      width: var(--slotSize);
      flex: 0 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:1px;                    /* 3 → 1（写真と表示名の間） */
    }
    .slot{
      width: var(--slotSize);
      aspect-ratio: 1 / 1;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(10,96,255,.06);
      border: 2px solid rgba(10,35,90,.16);
      cursor:pointer;
      touch-action: manipulation;
    }
    .slot img{width:100%;height:100%;object-fit:cover;display:block;border-radius:999px;}
    .slot.empty{background: rgba(10,96,255,.04); border: 1px dashed rgba(10,35,90,.22);}

    .slotInfo{
      width:100%;
      text-align:center;
      line-height:1.0;            /* 1.05 → 1.0 */
      display:flex; flex-direction:column;
      gap:0px;                    /* 1 → 0 */
    }
    .slotInfo .line{
      white-space: normal;
      word-break: break-word;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      font-size: clamp(8px, 2.6vw, 10px);
      color: rgba(11,16,32,.92);
    }

    /* ===== Bench panel（そのまま） ===== */
    #benchPanel{
      padding: 8px 6px 10px;
      overflow: visible;
    }
    .benchRow{
      display:flex; gap:10px;
      overflow-x:auto;
      padding-bottom:2px;
      -webkit-overflow-scrolling: touch;
    }
    .benchItemWrap{
      width:var(--benchSize);
      flex:0 0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:3px;
    }
    .benchItem{
      width: var(--benchSize);
      aspect-ratio:1/1;
      border-radius:999px;
      overflow:hidden;
      background: rgba(10,96,255,.06);
      border:2px solid rgba(10,35,90,.16);
      cursor:pointer;
      touch-action: manipulation;
    }
    .benchItem img{width:100%;height:100%;object-fit:cover;display:block;}

    .benchInfo{
      width:100%;
      text-align:center;
      line-height:1.05;
      display:flex;
      flex-direction:column;
      gap:1px;
    }
    .benchInfo .line{
      white-space: normal;
      word-break: break-word;
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      font-size: clamp(8px, 2.6vw, 10px);
      color: rgba(11,16,32,.92);
    }

    .benchCollapsed .benchRow{ display:none; }
    .benchCollapsed{ padding-bottom:8px; }

    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin:0 0 6px;
      font-size:12px;
      color: var(--muted);
    }
    .bar strong{color:var(--text); font-weight:900}
    .benchTitlePad{ padding-left: .5em; }

    .belowBenchControls{
      margin-top: 10px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(10,96,255,.06);
      color: var(--text);
      font-size: 12px;
      user-select:none;
      white-space:nowrap;
    }
    .chip input{ accent-color: var(--accent); }

    .optionsPanel{
      margin-top: 12px;
      background: rgba(255,255,255,.70);
      border: 1px solid var(--line);
      border-radius: var(--r);
      padding: 10px;
      box-shadow: var(--shadow);
    }

    .optionsTitleBtn{
      width: 100%;
      justify-content: space-between;
      height: 36px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(10,96,255,.06);
      padding: 0 12px;
      font-size: 12px;
      color: var(--muted);
    }
    .optionsTitleBtn strong{
      color: var(--muted);
      font-weight: 700;
    }
    .optionsTitleBtn .right{
      display:inline-flex;
      align-items:center;
      gap:10px;
      color: var(--muted);
      white-space: nowrap;
    }
    .optionsTitleBtn .picked{
      color: var(--text);
      font-weight: 900;
      max-width: 55vw;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sortTitle{
      font-size:12px;
      color:var(--muted);
      margin: 10px 0 8px;
    }

    .sortBox{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    select{
      height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.86);
      color:var(--text);
      padding:0 12px;
      outline:none;
    }

    .gridSection{margin-top:12px}
    .grid{display:grid;gap:10px;grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));}
    @media (max-width:1100px){ .grid{ grid-template-columns: repeat(4, 1fr); } }
    @media (max-width:360px){ .grid{ grid-template-columns: repeat(3, 1fr); } }

    .card{
      position:relative;
      background: var(--card);
      border:2px solid rgba(10,35,90,.14);
      border-radius:14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      transition: transform .12s ease;
    }
    .card:hover{transform: translateY(-2px)}
    .thumb{
      aspect-ratio: 1 / 1;
      width:100%;
      background: rgba(10,96,255,.06);
      display:block;
      object-fit: cover;
    }
    .meta{padding:8px 8px 10px}
    .name{font-size:13px;font-weight:900;line-height:1.2;margin:0 0 4px;color:var(--text)}
    .sub{font-size:11px;color:var(--muted);margin:0}

    .idx{
      position:absolute;
      top:8px; left:8px;
      height:20px;
      padding:0 7px;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      font-size:11px;
      font-weight:900;
      color: rgba(11,16,32,.92);
      background: rgba(255,255,255,.80);
      border:1px solid rgba(10,35,90,.18);
      backdrop-filter: blur(6px);
    }

    /* ===== Modal ===== */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(11,16,32,.38);
      backdrop-filter: blur(4px);
      z-index: 999;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    .modalOverlay.isOpen{ display:flex; }

    .modal{
      width: min(640px, 100%);
      background: rgba(255,255,255,.96);
      border: 1px solid var(--line);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 12px 12px;
      border-bottom: 1px solid var(--line);
      background: rgba(255,255,255,.86);
      position: sticky;
      top: 0;
      z-index: 2;
    }
    .modalHeader .title{
      font-size: 13px;
      font-weight: 900;
      color: var(--text);
      margin: 0;
    }
    .modalHeader .hint{
      font-size: 11px;
      color: var(--muted);
      margin: 2px 0 0;
    }
    .modalBody{
      padding: 10px 12px 12px;
      max-height: min(60vh, 520px);
      overflow: auto;
    }

    .modalToggles{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }

    .chipToggle{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--line);
      background: rgba(10,96,255,.06);
      color: var(--text);
      font-size:12px; user-select:none; white-space:nowrap;
    }
    .chipToggle input{ accent-color: var(--accent); }
    .chipToggle input:disabled{ opacity:.5; }

    .modalFooter{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding: 12px;
      border-top: 1px solid var(--line);
      background: rgba(255,255,255,.86);
    }
    .btnGhost{
      background: rgba(10,96,255,.04);
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <h1>日プ新世界 ピラミッドメーカー</h1>
  </div>
</header>

<main>
  <section class="stickyWrap">
    <div class="panel" id="pyramidPanel">
      <div class="rankBar" id="rankBar">
        <div class="rankTitlePad">
          <strong>11pick</strong>
          <span id="rankStats"></span>
        </div>
        <button id="togglePyramidLock" type="button" class="arrowBtn" title="表示固定">▾</button>
      </div>

      <div class="pyramidBody">
        <div class="pyramidTopGap"></div>
        <div class="rows" id="pyramid"></div>

        <div class="rankDatePad" id="rankDatePad"></div>
      </div>

      <div class="rankDate" id="rankDate"></div>
    </div>

    <div class="panel" id="benchPanel">
      <div class="bar">
        <div class="benchTitlePad"><strong>ベンチ</strong> <span id="benchCount"></span></div>
        <button id="toggleBench" type="button" class="arrowBtn">▾</button>
      </div>
      <div class="benchRow" id="bench"></div>
    </div>
  </section>

  <div class="belowBenchControls">
    <button id="clear" type="button" title="全解除">
      <svg class="btnIcon" viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M9 3h6l1 2h5v2H3V5h5l1-2Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>
        <path d="M6 9v11a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1V9" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <path d="M10 12v6M14 12v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
      全解除
    </button>

    <label class="chip">
      <input id="frameToggle" type="checkbox">
      枠色（シグナルソングクラス）
    </label>
  </div>

  <section class="optionsPanel">
    <button id="openDisplayModal" type="button" class="optionsTitleBtn" title="表示する項目を選ぶ">
      <strong>表示する項目（3つまで）</strong>
      <span class="right">
        <span class="picked" id="pickedSummary">未選択</span>
        <span aria-hidden="true">▾</span>
      </span>
    </button>

    <p class="sortTitle">並び替え</p>
    <div class="sortBox">
      <select id="sortKey"></select>
      <select id="sortDir">
        <option value="asc">昇順</option>
        <option value="desc">降順</option>
      </select>
    </div>
  </section>

  <section class="gridSection">
    <div class="grid" id="grid"></div>
  </section>
</main>

<div class="modalOverlay" id="displayModal" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="displayModalTitle">
    <div class="modalHeader">
      <div>
        <p class="title" id="displayModalTitle">表示する項目（3つまで）</p>
        <p class="hint" id="displayModalHint">チェックは最大3つまで</p>
      </div>
      <button type="button" id="closeDisplayModal" class="arrowBtn" aria-label="閉じる">✕</button>
    </div>

    <div class="modalBody">
      <div class="modalToggles" id="modalToggles"></div>
    </div>

    <div class="modalFooter">
      <button type="button" id="displayModalClear" class="btnGhost">全解除</button>
      <button type="button" id="displayModalDone">完了</button>
    </div>
  </div>
</div>

<script>
  const CSV_PATH = "data/master.csv";
  const STORAGE_KEY = "pyramid_maker_state_v8";

  const gridEl = document.getElementById("grid");
  const pyramidEl = document.getElementById("pyramid");
  const benchEl = document.getElementById("bench");
  const benchCountEl = document.getElementById("benchCount");
  const pyramidPanelEl = document.getElementById("pyramidPanel");
  const benchPanelEl = document.getElementById("benchPanel");
  const rankBarEl = document.getElementById("rankBar");

  const sortKeyEl = document.getElementById("sortKey");
  const sortDirEl = document.getElementById("sortDir");

  const clearBtn = document.getElementById("clear");
  const frameToggleEl = document.getElementById("frameToggle");
  const benchToggleBtn = document.getElementById("toggleBench");
  const pyramidLockBtn = document.getElementById("togglePyramidLock");
  const rankStatsEl = document.getElementById("rankStats");
  const rankDateEl = document.getElementById("rankDate");
  const rankDatePadEl = document.getElementById("rankDatePad");

  const openDisplayModalBtn = document.getElementById("openDisplayModal");
  const displayModalEl = document.getElementById("displayModal");
  const closeDisplayModalBtn = document.getElementById("closeDisplayModal");
  const modalTogglesEl = document.getElementById("modalToggles");
  const displayModalClearBtn = document.getElementById("displayModalClear");
  const displayModalDoneBtn = document.getElementById("displayModalDone");
  const pickedSummaryEl = document.getElementById("pickedSummary");

  const ROWS = [1,2,3,5];
  const TOTAL = ROWS.reduce((a,b)=>a+b,0);

  const EXCLUDE_KEYS = new Set([
    "id","ID","Id",
    "img","image","Image","画像","photo","Photo",
    "__idx"
  ]);

  const CLASS_COL = "シグナルソングクラス";
  const CLASS_COL_ALT = "signal_class";

  const CLASS_COLOR = {
    "A":"#ff69b4",
    "B":"#ffa500",
    "C":"#7fffd4",
    "D":"#080000",
    "F":"#d3d3d3"
  };

  const YEAR_COL = "年/Year";
  const HEIGHT_COL = "身長/Height";

  const state = {
    header: [],
    people: [],
    byId: new Map(),

    slots: Array(TOTAL).fill(null),
    bench: [],

    activeSlotIndex: null,
    activeBenchIndex: null,

    displayKeys: [],
    show: {},

    sortKeys: [],
    lastTappedId: null,

    benchCollapsed: false,
    classFrameOn: false,

    pyramidLockFull: true,
    _savedSortKey: null,
  };

  let cardElsById = new Map();
  let modalDraftShow = null;

  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

  function splitCsvLine(line){
    const out = [];
    let cur = "";
    let inQ = false;
    for (let i=0;i<line.length;i++){
      const c = line[i];
      if (c === '"'){
        if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
        else inQ = !inQ;
      } else if (c === "," && !inQ){
        out.push(cur); cur = "";
      } else {
        cur += c;
      }
    }
    out.push(cur);
    return out;
  }

  function parseCsvWithHeader(text){
    const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.trim() !== "");
    if (!lines.length) return { header: [], rows: [] };
    const header = splitCsvLine(lines[0]).map(h => h.trim());
    const rows = [];
    for (let i=1;i<lines.length;i++){
      const cols = splitCsvLine(lines[i]);
      const obj = {};
      for (let j=0;j<header.length;j++){
        obj[header[j]] = (cols[j] ?? "").trim();
      }
      rows.push(obj);
    }
    return { header, rows };
  }

  function pickField(obj, keys){
    for (const k of keys){
      if (obj[k] != null && String(obj[k]).trim() !== "") return String(obj[k]).trim();
    }
    return "";
  }

  function normalizePeople(rows){
    return rows.map((r, idx) => {
      const id = pickField(r, ["id","ID","Id"]) || String(idx+1);
      const img  = pickField(r, ["img","image","Image","画像","photo","Photo"]);
      return { id, img, raw: r, __idx: idx };
    });
  }

  function isInSlots(id){ return state.slots.includes(id); }
  function isInBench(id){ return state.bench.includes(id); }
  function isSelected(id){ return isInSlots(id) || isInBench(id); }

  function removeIdEverywhere(id){
    const si = state.slots.indexOf(id);
    if (si >= 0) state.slots[si] = null;
    const bi = state.bench.indexOf(id);
    if (bi >= 0) state.bench.splice(bi, 1);
  }

  function firstEmptySlot(){ return state.slots.findIndex(x => !x); }

  function swapSlots(a, b){
    const tmp = state.slots[a];
    state.slots[a] = state.slots[b];
    state.slots[b] = tmp;
  }

  function swapBench(a, b){
    const tmp = state.bench[a];
    state.bench[a] = state.bench[b];
    state.bench[b] = tmp;
  }

  function swapSlotWithBench(slotIndex, benchIndex){
    const slotId = state.slots[slotIndex] || null;
    const benchId = state.bench[benchIndex] || null;
    if (!benchId) return;

    state.slots[slotIndex] = benchId;

    if (slotId){
      state.bench[benchIndex] = slotId;
    } else {
      state.bench.splice(benchIndex, 1);
    }
  }

  function getClassColor(person){
    if (!person) return "";
    const cls = (person.raw?.[CLASS_COL] || person.raw?.[CLASS_COL_ALT] || "").trim();
    return CLASS_COLOR[cls] || "";
  }

  function getCssNumber(varName){
    const v = getComputedStyle(document.documentElement).getPropertyValue(varName);
    const n = parseFloat(v);
    return Number.isFinite(n) ? n : 0;
  }

  function formatTodayYMD(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const da = String(d.getDate()).padStart(2,"0");
    return `${y}/${m}/${da}`;
  }

  function setRankDateVisible(visible){
    rankDateEl.style.display = visible ? "" : "none";
    rankDatePadEl.style.display = visible ? "" : "none";
  }

  function applyPyramidScrollSizing(){
    if (state.pyramidLockFull){
      pyramidPanelEl.style.maxHeight = "";
      pyramidPanelEl.style.overflow = "hidden";
      setRankDateVisible(true);
      return;
    }

    setRankDateVisible(false);

    const slotSize = getCssNumber("--slotSize");
    const barH = rankBarEl ? rankBarEl.offsetHeight : 44;

    const infoH = 40;
    const extra = 14;
    const minH = Math.round(barH + 6 + slotSize + infoH + extra);

    pyramidPanelEl.style.maxHeight = `${minH}px`;
    pyramidPanelEl.style.overflow = "auto";     /* 折りたたみ時だけスクロール */
  }

  function updateSlotSize(){
    const st = getComputedStyle(pyramidPanelEl);
    const inner = Math.max(0, pyramidPanelEl.clientWidth);

    const root = getComputedStyle(document.documentElement);
    const gap = parseFloat(root.getPropertyValue("--gap")) || 6;
    const slotMax = parseFloat(root.getPropertyValue("--slotMax")) || 96;

    const size = Math.min(slotMax, Math.floor((inner - (12) - (4 * gap)) / 5));
    document.documentElement.style.setProperty("--slotSize", Math.max(64, size) + "px");
    document.documentElement.style.setProperty("--benchSize", Math.max(64, size) + "px");
  }

  function selectedToggleCount(showObj = state.show){
    let c = 0;
    for (const k of state.displayKeys){
      if (showObj[k]) c++;
    }
    return c;
  }

  function buildInfoLines(person){
    if (!person) return [];
    const r = person.raw || {};
    const lines = [];
    for (const key of state.displayKeys){
      if (!state.show[key]) continue;
      const v = (r[key] ?? "").trim();
      if (!v) continue;
      lines.push(v);
      if (lines.length >= 3) break;
    }
    return lines;
  }

  function buildSortKeys(header){
    const excludeForSort = new Set(["img","image","Image","画像","photo","Photo"]);
    return header.filter(h => h && !excludeForSort.has(h));
  }

  function toSortableValue(v){
    const s = String(v ?? "").trim();
    const n = Number(s);
    if (s !== "" && Number.isFinite(n)) return { type:"num", v:n };
    return { type:"str", v:s };
  }

  function getSortedPeople(){
    const arr = [...state.people];
    const key = sortKeyEl.value;
    const dir = sortDirEl.value;

    arr.sort((a,b) => {
      const av = toSortableValue(a.raw[key]);
      const bv = toSortableValue(b.raw[key]);

      let cmp = 0;
      if (av.type === "num" && bv.type === "num") cmp = av.v - bv.v;
      else cmp = String(av.v).localeCompare(String(bv.v), "ja", { numeric:true, sensitivity:"base" });

      return dir === "desc" ? -cmp : cmp;
    });

    return arr;
  }

  function renderPyramid(){
    let cursor = 0;

    pyramidEl.innerHTML = ROWS.map(n => {
      const items = [];
      for (let i=0;i<n;i++){
        const idx = cursor++;
        const id = state.slots[idx];
        const p = id ? state.byId.get(id) : null;
        const imgSrc = p?.img ? escapeHtml(p.img) : "";
        const lines = buildInfoLines(p);

        const frameColor = (state.classFrameOn ? getClassColor(p) : "");
        const style = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

        const slotCls = [
          "slot",
          (state.activeSlotIndex === idx) ? "activeRing" : "",
          id ? "" : "empty",
        ].filter(Boolean).join(" ");

        items.push(`
          <div class="slotWrap">
            <div class="${slotCls}" ${style} data-slot="${idx}" role="button" tabindex="0">
              ${id && imgSrc ? `<img src="${imgSrc}" alt="" loading="lazy" />` : ``}
            </div>
            ${lines.length ? `
              <div class="slotInfo">
                ${lines.map(t => `<div class="line">${escapeHtml(t)}</div>`).join("")}
              </div>
            ` : ``}
          </div>
        `);
      }
      return `<div class="row">${items.join("")}</div>`;
    }).join("");

    updateRankStats();
    applyPyramidScrollSizing();
  }

  function renderBench(){
    benchPanelEl.classList.toggle("benchCollapsed", state.benchCollapsed);
    benchToggleBtn.textContent = state.benchCollapsed ? "▴" : "▾";
    benchCountEl.textContent = state.bench.length ? `（${state.bench.length}）` : "";

    if (state.benchCollapsed){
      benchEl.innerHTML = "";
      return;
    }

    benchEl.innerHTML = state.bench.map((id, i) => {
      const p = state.byId.get(id);
      const imgSrc = p?.img ? escapeHtml(p.img) : "";
      const lines = buildInfoLines(p);

      const frameColor = (state.classFrameOn ? getClassColor(p) : "");
      const style = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

      const cls = [
        "benchItem",
        (state.activeBenchIndex === i) ? "activeRing" : ""
      ].filter(Boolean).join(" ");

      return `
        <div class="benchItemWrap">
          <div class="${cls}" ${style} data-index="${i}" data-id="${escapeHtml(id)}" role="button" tabindex="0">
            ${imgSrc ? `<img src="${imgSrc}" alt="" loading="lazy" />` : ``}
          </div>
          ${lines.length ? `
            <div class="benchInfo">
              ${lines.slice(0,3).map(t => `<div class="line">${escapeHtml(t)}</div>`).join("")}
            </div>
          ` : ``}
        </div>
      `;
    }).join("");

    updateRankStats();
  }

  function getCardTitleAndSub(person){
    const lines = buildInfoLines(person);

    const fallbackNameKey = state.header.includes("Name") ? "Name"
      : state.header.includes("名前") ? "名前"
      : null;

    const title = lines[0] || (fallbackNameKey ? (person.raw[fallbackNameKey] || "") : "");
    const sub = lines.slice(1,3).join(" / ");

    return { title, sub };
  }

  function renderGrid(){
    const arr = getSortedPeople();

    gridEl.innerHTML = arr.map((p, i) => {
      const imgSrc = p.img ? escapeHtml(p.img) : "";
      const { title, sub } = getCardTitleAndSub(p);
      const idx = i + 1;

      const frameColor = (state.classFrameOn ? getClassColor(p) : "");
      const borderStyle = frameColor ? `style="border-color:${escapeHtml(frameColor)}"` : "";

      return `
        <div class="card" ${borderStyle} data-id="${escapeHtml(p.id)}" role="button" tabindex="0">
          <span class="idx">${idx}</span>
          ${
            imgSrc
              ? `<img class="thumb" src="${imgSrc}" alt="${escapeHtml(title)}" loading="lazy"
                   onerror="this.style.display='none'; this.insertAdjacentHTML('afterend','<div style=&quot;aspect-ratio:1/1;background:rgba(10,96,255,.06);display:block&quot;></div>')" />`
              : `<div style="aspect-ratio:1/1;background:rgba(10,96,255,.06);display:block"></div>`
          }
          <div class="meta">
            <p class="name">${escapeHtml(title)}</p>
            <p class="sub">${escapeHtml(sub)}</p>
          </div>
        </div>
      `;
    }).join("");

    cardElsById = new Map();
    gridEl.querySelectorAll(".card").forEach(el => {
      cardElsById.set(el.dataset.id, el);
    });

    updateGridSelectionRings();
  }

  function applyGridClassFrames(){
    cardElsById.forEach((el, id) => {
      if (!state.classFrameOn){
        el.style.borderColor = "rgba(10,35,90,.14)";
        return;
      }
      const p = state.byId.get(id);
      const c = getClassColor(p);
      el.style.borderColor = c ? c : "rgba(10,35,90,.14)";
    });
  }

  function updateGridSelectionRings(){
    let activeId = null;
    if (state.activeSlotIndex != null){
      activeId = state.slots[state.activeSlotIndex] || null;
    } else if (state.activeBenchIndex != null){
      activeId = state.bench[state.activeBenchIndex] || null;
    }

    cardElsById.forEach((el, id) => {
      const selected = isSelected(id);
      const active = (activeId === id);

      el.classList.toggle("selected", selected);
      el.classList.toggle("activeRing", active);
    });
  }

  function parseYearParens(v){
    const s = String(v ?? "").trim();
    if (!s) return null;
    const m = s.match(/\((\d{1,2})\)/);
    if (!m) return null;
    const yy = Number(m[1]);
    return Number.isFinite(yy) ? yy : null;
  }

  function parseHeightCm(v){
    const s = String(v ?? "").trim();
    if (!s) return null;
    const m = s.match(/(\d+(\.\d+)?)/);
    if (!m) return null;
    const n = Number(m[1]);
    return Number.isFinite(n) ? n : null;
  }

  function updateRankStats(){
    const ids = state.slots.filter(Boolean);

    let ageSum = 0, ageCnt = 0;
    let hSum = 0, hCnt = 0;

    for (const id of ids){
      const p = state.byId.get(id);
      if (!p) continue;

      const yy = parseYearParens(p.raw?.[YEAR_COL]);
      if (yy != null){
        const age = 26 - yy;
        if (Number.isFinite(age)){
          ageSum += age;
          ageCnt++;
        }
      }

      const h = parseHeightCm(p.raw?.[HEIGHT_COL]);
      if (h != null){
        hSum += h;
        hCnt++;
      }
    }

    const ageAvg = ageCnt ? Math.round((ageSum / ageCnt) * 10) / 10 : null;
    const hAvg   = hCnt ? Math.round((hSum / hCnt) * 10) / 10 : null;

    const ageText = (ageAvg == null) ? "--" : `${ageAvg}歳`;
    const hText   = (hAvg   == null) ? "--" : `${hAvg}cm`;

    rankStatsEl.textContent = `平均年齢：${ageText}　平均身長：${hText}`;
  }

  function onSlotClick(slotIndex){
    const slotId = state.slots[slotIndex] || null;

    if (state.activeBenchIndex != null){
      swapSlotWithBench(slotIndex, state.activeBenchIndex);

      state.activeBenchIndex = null;
      state.activeSlotIndex = null;
      state.lastTappedId = null;

      renderPyramid();
      renderBench();
      updateGridSelectionRings();
      persistSoon();
      return;
    }

    if (state.activeSlotIndex === slotIndex){
      if (slotId) state.slots[slotIndex] = null;

      state.activeSlotIndex = null;
      state.lastTappedId = null;

      renderPyramid();
      updateGridSelectionRings();
      persistSoon();
      return;
    }

    if (state.activeSlotIndex != null && state.activeSlotIndex !== slotIndex){
      swapSlots(state.activeSlotIndex, slotIndex);

      state.activeSlotIndex = null;
      state.lastTappedId = null;

      renderPyramid();
      updateGridSelectionRings();
      persistSoon();
      return;
    }

    state.activeSlotIndex = slotIndex;
    state.activeBenchIndex = null;
    state.lastTappedId = slotId;

    renderPyramid();
    renderBench();
    updateGridSelectionRings();
  }

  function onPickId(id, fromBench=false, benchIndex=null){
    if (state.lastTappedId === id && isSelected(id)){
      removeIdEverywhere(id);

      state.lastTappedId = null;
      state.activeBenchIndex = null;
      state.activeSlotIndex = null;

      renderPyramid();
      renderBench();
      updateGridSelectionRings();
      persistSoon();
      return;
    }

    if (state.activeSlotIndex != null){
      if (fromBench && benchIndex != null){
        swapSlotWithBench(state.activeSlotIndex, benchIndex);
      } else {
        const bi = state.bench.indexOf(id);
        if (bi >= 0){
          swapSlotWithBench(state.activeSlotIndex, bi);
        } else {
          const occupant = state.slots[state.activeSlotIndex] || null;
          state.slots[state.activeSlotIndex] = id;
          if (occupant) state.bench.push(occupant);
        }
      }

      state.activeSlotIndex = null;
      state.activeBenchIndex = null;
      state.lastTappedId = null;

      renderPyramid();
      renderBench();
      updateGridSelectionRings();
      persistSoon();
      return;
    }

    state.lastTappedId = id;

    if (!isSelected(id)){
      const empty = firstEmptySlot();
      if (empty >= 0) state.slots[empty] = id;
      else state.bench.push(id);

      state.lastTappedId = null;
      state.activeBenchIndex = null;

      renderPyramid();
      renderBench();
      updateGridSelectionRings();
      persistSoon();
      return;
    }

    if (fromBench && benchIndex != null){
      if (state.activeBenchIndex != null && state.activeBenchIndex !== benchIndex){
        swapBench(state.activeBenchIndex, benchIndex);

        state.activeBenchIndex = null;
        state.lastTappedId = null;

        renderBench();
        updateGridSelectionRings();
        persistSoon();
        return;
      }

      state.activeBenchIndex = benchIndex;
      state.activeSlotIndex = null;

      renderBench();
      renderPyramid();
      updateGridSelectionRings();
      return;
    }

    const bi = state.bench.indexOf(id);
    state.activeBenchIndex = (bi >= 0) ? bi : null;
    state.activeSlotIndex = null;

    renderBench();
    renderPyramid();
    updateGridSelectionRings();
  }

  let persistTimer = null;
  function persistSoon(){
    clearTimeout(persistTimer);
    persistTimer = setTimeout(persistNow, 120);
  }

  function persistNow(){
    const payload = {
      slots: state.slots,
      bench: state.bench,
      show: state.show,
      sortKey: sortKeyEl.value,
      sortDir: sortDirEl.value,
      benchCollapsed: state.benchCollapsed,
      classFrameOn: state.classFrameOn,
      pyramidLockFull: state.pyramidLockFull,
    };
    try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(payload)); }catch(_){}
  }

  function restoreFromStorage(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const p = JSON.parse(raw);

      if (Array.isArray(p.slots)){
        state.slots = p.slots.slice(0, TOTAL).concat(Array(Math.max(0, TOTAL - p.slots.length)).fill(null)).slice(0, TOTAL);
      }
      if (Array.isArray(p.bench)) state.bench = p.bench.slice();

      if (p && typeof p.show === "object" && p.show){
        state.show = { ...p.show };
      }

      if (typeof p.benchCollapsed === "boolean") state.benchCollapsed = p.benchCollapsed;
      if (typeof p.classFrameOn === "boolean") state.classFrameOn = p.classFrameOn;
      if (typeof p.pyramidLockFull === "boolean") state.pyramidLockFull = p.pyramidLockFull;

      if (typeof p.sortDir === "string") sortDirEl.value = p.sortDir;
      state._savedSortKey = (typeof p.sortKey === "string") ? p.sortKey : null;

    }catch(_){}
  }

  function getPickedKeys(showObj = state.show){
    const picked = [];
    for (const k of state.displayKeys){
      if (showObj[k]) picked.push(k);
    }
    return picked;
  }

  function updatePickedSummary(){
    const picked = getPickedKeys(state.show);
    pickedSummaryEl.textContent = picked.length ? picked.join(" / ") : "未選択";
  }

  function openDisplayModal(){
    modalDraftShow = { ...state.show };
    renderModalToggles();
    displayModalEl.classList.add("isOpen");
    displayModalEl.setAttribute("aria-hidden","false");
    document.body.style.overflow = "hidden";
  }

  function closeDisplayModal(){
    displayModalEl.classList.remove("isOpen");
    displayModalEl.setAttribute("aria-hidden","true");
    document.body.style.overflow = "";
    modalDraftShow = null;
  }

  function renderModalToggles(){
    const picked = selectedToggleCount(modalDraftShow);
    const max = 3;
    const disableNew = picked >= max;

    modalTogglesEl.innerHTML = state.displayKeys.map(key => {
      const checked = modalDraftShow[key] ? "checked" : "";
      const disabled = (!modalDraftShow[key] && disableNew) ? "disabled" : "";
      return `
        <label class="chipToggle">
          <input type="checkbox" data-key="${escapeHtml(key)}" ${checked} ${disabled}>
          ${escapeHtml(key)}
        </label>
      `;
    }).join("");
  }

  modalTogglesEl.addEventListener("change", (e) => {
    const cb = e.target.closest("input[type=checkbox]");
    if (!cb) return;
    const key = cb.dataset.key;

    const currentlyOn = selectedToggleCount(modalDraftShow);
    if (!modalDraftShow[key] && cb.checked && currentlyOn >= 3){
      cb.checked = false;
      return;
    }

    modalDraftShow[key] = cb.checked;
    renderModalToggles();
  });

  openDisplayModalBtn.addEventListener("click", openDisplayModal);
  closeDisplayModalBtn.addEventListener("click", closeDisplayModal);

  displayModalClearBtn.addEventListener("click", () => {
    for (const k of state.displayKeys) modalDraftShow[k] = false;
    renderModalToggles();
  });

  displayModalDoneBtn.addEventListener("click", () => {
    state.show = { ...modalDraftShow };
    closeDisplayModal();

    renderPyramid();
    renderBench();
    renderGrid();
    applyGridClassFrames();
    updateGridSelectionRings();
    updatePickedSummary();
    persistSoon();
  });

  displayModalEl.addEventListener("click", (e) => {
    if (e.target === displayModalEl) closeDisplayModal();
  });
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && displayModalEl.classList.contains("isOpen")) closeDisplayModal();
  });

  frameToggleEl.addEventListener("change", () => {
    state.classFrameOn = frameToggleEl.checked;
    renderPyramid();
    renderBench();
    applyGridClassFrames();
    updateGridSelectionRings();
    persistSoon();
  });

  sortKeyEl.addEventListener("change", () => {
    renderGrid();
    applyGridClassFrames();
    updateGridSelectionRings();
    persistSoon();
  });
  sortDirEl.addEventListener("change", () => {
    renderGrid();
    applyGridClassFrames();
    updateGridSelectionRings();
    persistSoon();
  });

  clearBtn.addEventListener("click", () => {
    const ok = confirm("選択を解除しますか？");
    if (!ok) return;

    state.slots = Array(TOTAL).fill(null);
    state.bench = [];
    state.activeSlotIndex = null;
    state.activeBenchIndex = null;
    state.lastTappedId = null;

    renderPyramid();
    renderBench();
    updateGridSelectionRings();
    persistSoon();
  });

  benchToggleBtn.addEventListener("click", () => {
    state.benchCollapsed = !state.benchCollapsed;
    renderBench();
    persistSoon();
  });

  pyramidLockBtn.addEventListener("click", () => {
    state.pyramidLockFull = !state.pyramidLockFull;
    pyramidLockBtn.textContent = state.pyramidLockFull ? "▾" : "▴";
    applyPyramidScrollSizing();
    persistSoon();
  });

  pyramidEl.addEventListener("click", (e) => {
    const slot = e.target.closest(".slot");
    if (!slot) return;
    onSlotClick(Number(slot.dataset.slot));
  });

  benchEl.addEventListener("click", (e) => {
    const item = e.target.closest(".benchItem");
    if (!item) return;
    onPickId(item.dataset.id, true, Number(item.dataset.index));
  });

  gridEl.addEventListener("click", (e) => {
    const card = e.target.closest(".card");
    if (!card) return;
    onPickId(card.dataset.id, false, null);
  });

  window.addEventListener("resize", () => {
    updateSlotSize();
    renderPyramid();
    renderBench();
  });

  async function loadData(){
    restoreFromStorage();
    rankDateEl.textContent = formatTodayYMD();

    const res = await fetch(CSV_PATH, { cache: "no-store" });
    const text = await res.text();
    const { header, rows } = parseCsvWithHeader(text);

    state.header = header;

    state.displayKeys = header.filter(h => h && !EXCLUDE_KEYS.has(h));
    for (const k of state.displayKeys){
      if (!(k in state.show)) state.show[k] = false;
    }
    for (const k of Object.keys(state.show)){
      if (!state.displayKeys.includes(k)) delete state.show[k];
    }

    state.sortKeys = buildSortKeys(header);
    sortKeyEl.innerHTML = state.sortKeys.map(k =>
      `<option value="${escapeHtml(k)}">${escapeHtml(k)}</option>`
    ).join("");

    if (state.sortKeys.includes("Name")) sortKeyEl.value = "Name";
    else if (state.sortKeys.includes("名前")) sortKeyEl.value = "名前";
    else sortKeyEl.value = state.sortKeys[0] || "";

    if (state._savedSortKey && state.sortKeys.includes(state._savedSortKey)){
      sortKeyEl.value = state._savedSortKey;
    }
    state._savedSortKey = null;

    state.people = normalizePeople(rows);
    state.byId = new Map(state.people.map(p => [p.id, p]));

    state.slots = state.slots.map(id => (id && state.byId.has(id)) ? id : null);
    state.bench = state.bench.filter(id => state.byId.has(id));

    frameToggleEl.checked = state.classFrameOn;
    pyramidLockBtn.textContent = state.pyramidLockFull ? "▾" : "▴";

    updateSlotSize();
    renderPyramid();
    renderBench();
    renderGrid();
    applyGridClassFrames();
    updateGridSelectionRings();

    applyPyramidScrollSizing();
    updatePickedSummary();
    persistSoon();
  }

  loadData();
</script>
</body>
</html>
