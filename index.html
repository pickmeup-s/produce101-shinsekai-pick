<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Produce101 11人ピラミッドメーカー</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --panel:#121a2b;
      --panel2:#0f1626;
      --text:#e8eefc;
      --muted:#a9b6d6;
      --line:rgba(255,255,255,.12);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --r:14px;
      --stickyTop: 10px; /* JSで「スクロールしたら」変える */
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      background: radial-gradient(1200px 600px at 20% -10%, rgba(80,120,255,.25), transparent 60%),
                  radial-gradient(900px 500px at 80% 0%, rgba(160,90,255,.18), transparent 55%),
                  var(--bg);
      color:var(--text);
    }

    /* ヘッダーは最初は通常、スクロール後だけ固定に見えるようにする */
    header{
      position:relative;
      background: rgba(11,15,26,.72);
      border-bottom:1px solid var(--line);
    }
    header.isStuck{
      position:sticky; top:0; z-index:50;
      backdrop-filter: blur(10px);
    }

    .wrap{max-width:1100px;margin:0 auto;padding:12px 16px}
    .top{display:flex; align-items:center; justify-content:space-between; gap:12px}
    h1{margin:0;font-size:18px;font-weight:700;letter-spacing:.2px}

    .controls{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
    }
    select, button{
      height:36px;
      border-radius:10px;
      border:1px solid var(--line);
      background: rgba(18,26,43,.9);
      color:var(--text);
      padding:0 12px;
      outline:none;
    }
    button{
      cursor:pointer;
      background: linear-gradient(180deg, rgba(40,120,255,.9), rgba(30,90,210,.9));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 8px 18px rgba(30,90,210,.25);
    }
    button:active{transform: translateY(1px)}

    main{max-width:1100px;margin:0 auto;padding:14px 16px 60px}

    /* ✅ プレビュー：スクロールしたら固定（最初から固定しない） */
    .pyramidWrap{
      margin-top: 10px;
    }
    .pyramidWrap.isSticky{
      position: sticky;
      top: var(--stickyTop);
      z-index: 40;
    }
    .pyramid{
      background: rgba(18,26,43,.65);
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding:10px 10px 12px;
    }
    .hintBar{
      display:flex; align-items:center; justify-content:space-between;
      margin:0 0 8px; gap:10px; flex-wrap:wrap;
      color:var(--muted); font-size:12px;
    }
    .hintBar strong{color:var(--text); font-weight:700}
    .miniBtns{display:flex; gap:8px; align-items:center}

    /* 反映ボタンは不要：消す（見た目もDOMも） */
    .miniBtns{display:none}

    .row{
      display:flex;
      justify-content:center;
      gap:8px;
      margin:8px 0;
      flex-wrap:nowrap; /* ✅ 5人は折り返さない */
      overflow:hidden;
    }

    /* ✅ プレビュー側：丸、枠は丸（楕円にしない）、名前は省略しないで2行まで */
    .slot{
      width:64px; /* スマホで5人を収めるため小さめ */
      flex: 0 0 auto;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.04);
      overflow:hidden;
      box-shadow: 0 6px 14px rgba(0,0,0,.22);
    }
    .slot img{
      width:100%;
      aspect-ratio:1/1;
      object-fit:cover;
      display:block;
      border-radius:999px;
    }
    .slot .cap{
      padding:6px 6px 8px;
      font-size:10px;
      color:var(--text);
      text-align:center;

      /* ✅ 2行まで表示して、それ以上は… */
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient:vertical;
      overflow:hidden;
      line-height:1.15;
      min-height: 2.3em;
    }
    .slot.empty{
      border-style:dashed;
      box-shadow:none;
    }
    .slot.empty .cap{color:transparent}

    /* 一覧 */
    .gridSection{margin-top:12px}

    /* ✅ スマホは4列固定（小さくして一気に見れる） */
    .grid{
      display:grid;
      gap:10px;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    }
    @media (max-width: 640px){
      .grid{ grid-template-columns: repeat(4, 1fr); }
    }
    @media (max-width: 420px){
      .grid{ grid-template-columns: repeat(3, 1fr); }
    }

    .card{
      position:relative;
      background: linear-gradient(180deg, rgba(18,26,43,.9), rgba(15,22,38,.92));
      border:1px solid var(--line);
      border-radius: 14px;
      box-shadow: var(--shadow);
      overflow:hidden;
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, filter .12s ease;
      user-select:none;
    }
    .card:hover{transform: translateY(-2px)}
    .thumb{
      aspect-ratio: 1 / 1;
      width:100%;
      background: rgba(255,255,255,.06);
      display:block;
      object-fit: cover;
    }
    .meta{padding:8px 8px 10px}
    .name{font-size:13px;font-weight:700;line-height:1.2;margin:0 0 4px}
    .sub{font-size:11px;color:var(--muted);margin:0}
    .card.selected{
      border-color: rgba(110,190,255,.85);
      filter: saturate(1.05);
      box-shadow: 0 0 0 2px rgba(110,190,255,.25), var(--shadow);
    }

    /* 並び順番号バッジ */
    .idx{
      position:absolute;
      top:8px; left:8px;
      height:20px;
      padding:0 7px;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      font-size:11px;
      font-weight:800;
      color:rgba(255,255,255,.95);
      background: rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
    }

    /* 選択バッジ */
    .pick{
      position:absolute;
      top:8px; right:8px;
      height:20px;
      padding:0 7px;
      border-radius:999px;
      display:none;
      align-items:center;
      font-size:11px;
      font-weight:800;
      color:rgba(255,255,255,.95);
      background: rgba(40,120,255,.28);
      border:1px solid rgba(40,120,255,.45);
      backdrop-filter: blur(6px);
    }
    .card.selected .pick{display:inline-flex}
  </style>
</head>
<body>
  <header id="header">
    <div class="wrap">
      <div class="top">
        <h1>Produce101 11人ピラミッドメーカー</h1>
        <div class="controls">
          <select id="sort">
            <option value="registered">登録順</option>
            <option value="name_asc">名前 A→Z</option>
            <option value="name_desc">名前 Z→A</option>
          </select>
          <button id="reload" type="button">データ再読込</button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <!-- ✅ プレビューは「選んでる子が見える」ためのやつ。スクロールしたら固定 -->
    <section class="pyramidWrap" id="pyramidWrap">
      <div class="pyramid">
        <div class="hintBar">
          <div id="count"></div>
          <!-- 反映ボタンは消してる -->
          <div class="miniBtns"></div>
        </div>
        <div id="pyramid"></div>
      </div>
    </section>

    <section class="gridSection">
      <div class="grid" id="grid"></div>
    </section>
  </main>

  <script>
    const CSV_PATH = "data/master.csv";

    const headerEl = document.getElementById("header");
    const pyramidWrapEl = document.getElementById("pyramidWrap");
    const gridEl = document.getElementById("grid");
    const sortEl = document.getElementById("sort");
    const countEl = document.getElementById("count");
    const pyramidEl = document.getElementById("pyramid");

    const state = {
      people: [],
      selectedIds: new Set(),
      lastSortedIds: [],
    };

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }

    function splitCsvLine(line){
      const out = [];
      let cur = "";
      let inQ = false;
      for (let i=0;i<line.length;i++){
        const c = line[i];
        if (c === '"'){
          if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = !inQ;
        } else if (c === "," && !inQ){
          out.push(cur); cur = "";
        } else {
          cur += c;
        }
      }
      out.push(cur);
      return out;
    }

    function parseCsv(text){
      const lines = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.trim() !== "");
      if (!lines.length) return [];
      const header = splitCsvLine(lines[0]).map(h => h.trim());
      const rows = [];
      for (let i=1;i<lines.length;i++){
        const cols = splitCsvLine(lines[i]);
        const obj = {};
        for (let j=0;j<header.length;j++){
          obj[header[j]] = (cols[j] ?? "").trim();
        }
        rows.push(obj);
      }
      return rows;
    }

    function pickField(obj, keys){
      for (const k of keys){
        if (obj[k] != null && String(obj[k]).trim() !== "") return String(obj[k]).trim();
      }
      return "";
    }

    function normalizePeople(rows){
      return rows.map((r, idx) => {
        const id = pickField(r, ["id","ID","Id"]) || String(idx+1);

        // ✅ 一覧（選ぶ側）は情報多め：name / romaji / birthYear 想定
        const name = pickField(r, ["name","Name","名前","氏名"]);
        const romaji = pickField(r, ["romaji","Romaji","roman","ローマ字"]);
        const birth = pickField(r, ["birth","birthYear","year","生年","生年月日"]);
        const img  = pickField(r, ["img","image","Image","画像","photo","Photo"]);

        // ✅ 将来用：出身地など
        const origin = pickField(r, ["origin","出身地","出身","city","pref","prefecture"]);

        return { id, name, romaji, birth, img, origin, __idx: idx };
      });
    }

    function setCountText(){
      const n = state.selectedIds.size;
      countEl.textContent = n ? `選択中：${n}` : "";
    }

    function getSortedPeople(){
      const arr = [...state.people];
      const mode = sortEl.value;
      if (mode === "registered"){
        arr.sort((a,b) => a.__idx - b.__idx);
      } else if (mode === "name_asc"){
        arr.sort((a,b) => (a.name || "").localeCompare(b.name || "", "ja"));
      } else if (mode === "name_desc"){
        arr.sort((a,b) => (b.name || "").localeCompare(a.name || "", "ja"));
      }
      state.lastSortedIds = arr.map(p => p.id);
      return arr;
    }

    // ✅ 選ぶ側のサブ行（情報多め）
    function buildSubLineForGrid(p){
      const parts = [];
      if (p.romaji) parts.push(p.romaji);
      if (p.birth) parts.push(p.birth);
      if (p.origin) parts.push(p.origin);
      return parts.join(" / ");
    }

    function renderGrid(){
      const arr = getSortedPeople();
      const html = arr.map((p, i) => {
        const selected = state.selectedIds.has(p.id) ? "selected" : "";
        const imgSrc = p.img ? escapeHtml(p.img) : "";
        const name = escapeHtml(p.name || "");
        const sub = escapeHtml(buildSubLineForGrid(p));
        const idx = i + 1;

        return `
          <div class="card ${selected}" data-id="${escapeHtml(p.id)}" role="button" tabindex="0" aria-label="${name}">
            <span class="idx">${idx}</span>
            <span class="pick">選択</span>
            ${imgSrc
              ? `<img class="thumb" src="${imgSrc}" alt="${name}" loading="lazy"
                   onerror="this.style.display='none'; this.insertAdjacentHTML('afterend','<div style=&quot;aspect-ratio:1/1;background:rgba(255,255,255,.06);display:block&quot;></div>')" />`
              : `<div style="aspect-ratio:1/1;background:rgba(255,255,255,.06);display:block"></div>`
            }
            <div class="meta">
              <p class="name">${name}</p>
              <p class="sub">${sub}</p>
            </div>
          </div>
        `;
      }).join("");

      gridEl.innerHTML = html;
      setCountText();
    }

    // ✅ 選択したら即プレビュー反映（ボタン不要）
    function toggleSelect(id){
      if (state.selectedIds.has(id)) state.selectedIds.delete(id);
      else state.selectedIds.add(id);
      renderGrid();
      renderPyramidFromSelection(); // ← 即反映
    }

    function renderPyramidFromSelection(){
      // 現在の並び順で上から詰める
      const orderIds = state.lastSortedIds.length ? state.lastSortedIds : state.people.map(p => p.id);
      const picked = orderIds
        .filter(id => state.selectedIds.has(id))
        .map(id => state.people.find(p => p.id === id))
        .filter(Boolean);

      const rows = [1,2,3,5];
      const totalSlots = rows.reduce((a,b)=>a+b,0);
      const slots = picked.slice(0, totalSlots);

      let cursor = 0;
      const rowsHtml = rows.map(n => {
        const rowItems = [];
        for (let i=0;i<n;i++){
          const p = slots[cursor++];
          if (p){
            const imgSrc = p.img ? escapeHtml(p.img) : "";
            const name = escapeHtml(p.name || ""); // ✅ プレビューは名前だけ
            rowItems.push(`
              <div class="slot" title="${name}">
                ${imgSrc
                  ? `<img src="${imgSrc}" alt="${name}" loading="lazy"
                       onerror="this.style.display='none'; this.parentElement.classList.add('empty');" />`
                  : `<div style="aspect-ratio:1/1"></div>`
                }
                <div class="cap">${name}</div>
              </div>
            `);
          } else {
            rowItems.push(`<div class="slot empty"><div style="aspect-ratio:1/1"></div><div class="cap">.</div></div>`);
          }
        }
        return `<div class="row">${rowItems.join("")}</div>`;
      }).join("");

      pyramidEl.innerHTML = rowsHtml;
    }

    async function loadData(){
      const res = await fetch(CSV_PATH, { cache: "no-store" });
      const text = await res.text();
      const rows = parseCsv(text);
      state.people = normalizePeople(rows);
      state.selectedIds.clear();
      pyramidEl.innerHTML = "";
      renderGrid();
      renderPyramidFromSelection();
    }

    // ✅ スクロールしたらプレビューを固定にする（最初は固定しない）
    function setupScrollSticky(){
      const headerBottom = () => headerEl.getBoundingClientRect().bottom;

      function tick(){
        // ヘッダーは「スクロールしたら」sticky化（見え方の要望に合わせる）
        headerEl.classList.toggle("isStuck", window.scrollY > 10);

        // プレビューはヘッダーが画面上に消えていくくらいから固定
        const shouldStick = window.scrollY > 120; // ここは好みで微調整
        pyramidWrapEl.classList.toggle("isSticky", shouldStick);

        // sticky の top を「ヘッダーの高さ + 10」に追従
        const h = Math.ceil(headerEl.getBoundingClientRect().height || 0);
        document.documentElement.style.setProperty("--stickyTop", (h + 10) + "px");
      }

      window.addEventListener("scroll", tick, { passive:true });
      window.addEventListener("resize", tick);
      tick();
    }

    gridEl.addEventListener("click", (e) => {
      const card = e.target.closest(".card");
      if (!card) return;
      toggleSelect(card.dataset.id);
    });

    gridEl.addEventListener("keydown", (e) => {
      if (e.key !== "Enter" && e.key !== " ") return;
      const card = e.target.closest(".card");
      if (!card) return;
      e.preventDefault();
      toggleSelect(card.dataset.id);
    });

    sortEl.addEventListener("change", () => {
      renderGrid();
      renderPyramidFromSelection(); // 並び替えたらプレビューも即追従
    });

    document.getElementById("reload").addEventListener("click", loadData);

    setupScrollSticky();
    loadData();
  </script>
</body>
</html>
